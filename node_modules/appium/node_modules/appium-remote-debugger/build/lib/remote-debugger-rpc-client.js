// jshint ignore: start
'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _bplistCreator = require('bplist-creator');

var _bplistCreator2 = _interopRequireDefault(_bplistCreator);

var _bplistParser = require('bplist-parser');

var _bplistParser2 = _interopRequireDefault(_bplistParser);

var _bufferpack = require('bufferpack');

var _bufferpack2 = _interopRequireDefault(_bufferpack);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _remoteDebugger = require('./remote-debugger');

var _nodeUuid = require('node-uuid');

var _nodeUuid2 = _interopRequireDefault(_nodeUuid);

var _net = require('net');

var _net2 = _interopRequireDefault(_net);

var _remoteDebuggerMessageHandler = require('./remote-debugger-message-handler');

var _remoteDebuggerMessageHandler2 = _interopRequireDefault(_remoteDebuggerMessageHandler);

var _remoteMessages = require('./remote-messages');

var _remoteMessages2 = _interopRequireDefault(_remoteMessages);

var _helpers = require('./helpers');

var RemoteDebuggerRpcClient = (function () {
  function RemoteDebuggerRpcClient(host) {
    var port = arguments.length <= 1 || arguments[1] === undefined ? _remoteDebugger.REMOTE_DEBUGGER_PORT : arguments[1];
    var specialMessageHandlers = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    _classCallCheck(this, RemoteDebuggerRpcClient);

    // socket and connection configuration
    this.socket = null;
    this.host = host;
    this.port = port;
    this.connected = false;
    this.connId = _nodeUuid2['default'].v4();
    this.senderId = _nodeUuid2['default'].v4();
    this.curMsgId = 0;
    this.received = new Buffer(0);
    this.readPos = 0;

    // message handlers
    this.specialMessageHandlers = specialMessageHandlers;
    this.messageHandler = null;
  }

  _createClass(RemoteDebuggerRpcClient, [{
    key: 'connect',
    value: function connect() {
      return _regeneratorRuntime.async(function connect$(context$2$0) {
        var _this = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            this.messageHandler = new _remoteDebuggerMessageHandler2['default'](this.specialMessageHandlers);

            // create socket and handle its messages
            this.socket = new _net2['default'].Socket({ type: 'tcp6' });
            this.socket.setNoDelay(true);
            this.socket.on('close', function () {
              if (_this.connected) {
                _logger2['default'].debug('Debugger socket disconnected');
              }
              _this.connected = false;
              _this.socket = null;
            });
            this.socket.on('end', function () {
              _this.connected = false;
            });
            this.socket.on('data', this.receive.bind(this));

            // connect the socket
            context$2$0.next = 8;
            return _regeneratorRuntime.awrap(new _bluebird2['default'](function callee$2$0(resolve, reject) {
              return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                var _this2 = this;

                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    // only resolve this function when we are actually connected
                    this.socket.connect(this.port, '::1');
                    this.socket.on('connect', function callee$3$0() {
                      return _regeneratorRuntime.async(function callee$3$0$(context$4$0) {
                        while (1) switch (context$4$0.prev = context$4$0.next) {
                          case 0:
                            _logger2['default'].debug('Debugger socket connected to ' + this.socket.remoteAddress + ':' + this.socket.remotePort);
                            this.connected = true;

                            resolve();

                          case 3:
                          case 'end':
                            return context$4$0.stop();
                        }
                      }, null, _this2);
                    });
                    this.socket.on('error', function (exception) {
                      if (_this2.connected) {
                        _logger2['default'].error('Socket error: ' + exception.message);
                        _this2.connected = false;
                      }

                      // the connection was refused, so reject the connect promise
                      reject(exception);
                    });

                  case 3:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this);
            }));

          case 8:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 9:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'disconnect',
    value: function disconnect() {
      return _regeneratorRuntime.async(function disconnect$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (this.isConnected()) {
              _logger2['default'].debug('Disconnecting from remote debugger');
              this.socket.destroy();
            }
            this.connected = false;

          case 2:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'isConnected',
    value: function isConnected() {
      return this.connected;
    }
  }, {
    key: 'setSpecialMessageHandler',
    value: function setSpecialMessageHandler(key, errorHandler, handler) {
      this.messageHandler.setSpecialMessageHandler(key, errorHandler, handler);
    }
  }, {
    key: 'getSpecialMessageHandler',
    value: function getSpecialMessageHandler(key) {
      return this.messageHandler.getSpecialMessageHandler(key);
    }
  }, {
    key: 'setDataMessageHandler',
    value: function setDataMessageHandler(key, errorHandler, handler) {
      this.messageHandler.setDataMessageHandler(key, errorHandler, handler);
    }
  }, {
    key: 'allowNavigationWithoutReload',
    value: function allowNavigationWithoutReload() {
      var allow = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

      this.messageHandler.allowNavigationWithoutReload(allow);
    }
  }, {
    key: 'selectApp',
    value: function selectApp(appIdKey, applicationConnectedHandler) {
      return _regeneratorRuntime.async(function selectApp$(context$2$0) {
        var _this4 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(new _bluebird2['default'](function callee$2$0(resolve, reject) {
              var onAppChange, _ref, _ref2, connectedAppIdKey, pageDict, msg;

              return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                var _this3 = this;

                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    onAppChange = function onAppChange(dict) {
                      var oldAppIdKey, correctAppIdKey;
                      return _regeneratorRuntime.async(function onAppChange$(context$4$0) {
                        while (1) switch (context$4$0.prev = context$4$0.next) {
                          case 0:
                            oldAppIdKey = dict.WIRHostApplicationIdentifierKey;
                            correctAppIdKey = dict.WIRApplicationIdentifierKey;

                            // if this is a report of a proxy redirect from the remote debugger
                            // we want to update our dictionary and get a new app id
                            if (oldAppIdKey && correctAppIdKey !== oldAppIdKey) {
                              _logger2['default'].debug('We were notified we might have connected to the wrong app. ' + ('Using id ' + correctAppIdKey + ' instead of ' + oldAppIdKey));
                            }

                            applicationConnectedHandler(dict);
                            reject('New application has connected');

                          case 5:
                          case 'end':
                            return context$4$0.stop();
                        }
                      }, null, _this3);
                    };

                    this.setSpecialMessageHandler('_rpc_applicationConnected:', reject, onAppChange);

                    // do the actual connecting to the app
                    context$3$0.next = 4;
                    return _regeneratorRuntime.awrap(this.send('connectToApp', {
                      appIdKey: appIdKey
                    }));

                  case 4:
                    _ref = context$3$0.sent;
                    _ref2 = _slicedToArray(_ref, 2);
                    connectedAppIdKey = _ref2[0];
                    pageDict = _ref2[1];

                    // sometimes the connect logic happens, but with an empty dictionary
                    // which leads to the remote debugger getting disconnected, and into a loop
                    if (_lodash2['default'].isEmpty(pageDict)) {
                      msg = 'Empty page dictionary received';

                      _logger2['default'].debug(msg);
                      reject(new Error(msg));
                    } else {
                      resolve([connectedAppIdKey, pageDict]);
                    }

                  case 9:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this4);
            })['finally'](function () {
              // no matter what, we want to restore the handler that was changed.
              _this4.setSpecialMessageHandler('_rpc_applicationConnected:', null, applicationConnectedHandler);
            }));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'send',
    value: function send(command) {
      var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
      var onSocketError;
      return _regeneratorRuntime.async(function send$(context$2$0) {
        var _this6 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            onSocketError = undefined;
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap(new _bluebird2['default'](function callee$2$0(resolve, reject) {
              var data, socketCb, plist, msg;
              return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                var _this5 = this;

                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    // promise to be resolved whenever remote debugger
                    // replies to our request

                    // retrieve the correct command to send
                    opts = _lodash2['default'].defaults({ connId: this.connId, senderId: this.senderId }, opts);
                    data = (0, _remoteMessages2['default'])(command, opts);
                    socketCb = _lodash2['default'].noop;

                    // handle socket problems
                    onSocketError = function (exception) {
                      if (_this5.connected) {
                        _logger2['default'].error('Socket error: ' + exception.message);
                      }

                      // the connection was refused, so reject the connect promise
                      reject(exception);
                    };
                    this.socket.on('error', onSocketError);
                    if (this.messageHandler.hasSpecialMessageHandler(data.__selector)) {
                      (function () {
                        // special replies will return any number of arguments
                        // temporarily wrap with promise handling
                        var specialMessageHandler = _this5.getSpecialMessageHandler(data.__selector);
                        _this5.setSpecialMessageHandler(data.__selector, reject, (function () {
                          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                            args[_key] = arguments[_key];
                          }

                          _logger2['default'].debug('Received response from socket send: \'' + _lodash2['default'].truncate(JSON.stringify(args), { length: 50 }) + '\'');

                          // call the original listener, and put it back, if necessary
                          specialMessageHandler.apply(undefined, args);
                          if (this.messageHandler.hasSpecialMessageHandler(data.__selector)) {
                            // this means that the system has not removed this listener
                            this.setSpecialMessageHandler(data.__selector, null, specialMessageHandler);
                          }

                          resolve(args);
                        }).bind(_this5));
                      })();
                    } else if (data.__argument && data.__argument.WIRSocketDataKey) {
                      // keep track of the messages coming and going using
                      // a simple sequential id
                      this.curMsgId++;
                      this.setDataMessageHandler(this.curMsgId.toString(), reject, function (value) {
                        var msg = _lodash2['default'].truncate(_lodash2['default'].isString(value) ? value : JSON.stringify(value), { length: 50 });
                        _logger2['default'].debug('Received data response from socket send: \'' + msg + '\'');
                        _logger2['default'].debug('Original command: ' + command);
                        resolve(value);
                      });
                      data.__argument.WIRSocketDataKey.id = this.curMsgId;
                      data.__argument.WIRSocketDataKey = new Buffer(JSON.stringify(data.__argument.WIRSocketDataKey));
                    } else {
                      // we want to immediately resolve this socket.write
                      // any long term callbacks will do their business in the background
                      socketCb = resolve;
                    }

                    _logger2['default'].debug('Sending \'' + data.__selector + '\' message to remote debugger');

                    // remote debugger expects a binary plist as data
                    plist = undefined;
                    context$3$0.prev = 8;

                    plist = (0, _bplistCreator2['default'])(data);
                    context$3$0.next = 17;
                    break;

                  case 12:
                    context$3$0.prev = 12;
                    context$3$0.t0 = context$3$0['catch'](8);
                    msg = 'Could not create binary plist from data: ' + context$3$0.t0.message;

                    _logger2['default'].error(msg);
                    return context$3$0.abrupt('return', reject(new Error(msg)));

                  case 17:

                    if (this.socket && this.connected) {
                      // cork and uncork in order to not buffer the write
                      // on some systems this is necessary or the server
                      // gets confused.
                      this.socket.cork();
                      this.socket.write(_bufferpack2['default'].pack('L', [plist.length]));
                      this.socket.write(plist, socketCb);
                      this.socket.uncork();
                    } else {
                      msg = 'Attempted to write data to socket after it was closed!';

                      _logger2['default'].error(msg);
                      reject(new Error(msg));
                    }

                  case 18:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this6, [[8, 12]]);
            })['finally'](function () {
              // remove this listener, so we don't exhaust the system
              _this6.socket.removeListener('error', onSocketError);
            }));

          case 3:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 4:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'receive',
    value: function receive(data) {
      // Append this new data to the existing Buffer
      this.received = Buffer.concat([this.received, data]);
      var dataLeftOver = true;

      // Parse multiple messages in the same packet
      while (dataLeftOver) {
        // Store a reference to where we were
        var oldReadPos = this.readPos;

        // Read the prefix (plist length) to see how far to read next
        // It's always 4 bytes long
        var prefix = this.received.slice(this.readPos, this.readPos + 4);

        var msgLength = undefined;
        try {
          msgLength = _bufferpack2['default'].unpack('L', prefix)[0];
        } catch (e) {
          _logger2['default'].error('Buffer could not unpack: ' + e);
          return;
        }

        // Jump forward 4 bytes
        this.readPos += 4;

        // Is there enough data here?
        // If not, jump back to our original position and gtfo
        if (this.received.length < msgLength + this.readPos) {
          this.readPos = oldReadPos;
          break;
        }

        // Extract the main body of the message (where the plist should be)
        var body = this.received.slice(this.readPos, msgLength + this.readPos);

        // Extract the plist
        var plist = undefined;
        try {
          plist = _bplistParser2['default'].parseBuffer(body);
        } catch (e) {
          _logger2['default'].error('Error parsing binary plist: ' + e);
          return;
        }

        // bplistParse.parseBuffer returns an array
        if (plist.length === 1) {
          plist = plist[0];
        }

        var _arr = ['WIRMessageDataKey', 'WIRDestinationKey', 'WIRSocketDataKey'];
        for (var _i = 0; _i < _arr.length; _i++) {
          var key = _arr[_i];
          if (!_lodash2['default'].isUndefined(plist[key])) {
            plist[key] = plist[key].toString("utf8");
          }
        }

        if (plist.__selector === "_rpc_applicationSentData:") {
          _logger2['default'].debug('Received applicationSentData response');
        } else {
          _logger2['default'].debug('Receiving data from remote debugger: \'' + (0, _helpers.simpleStringify)(plist) + '\'');
        }

        // Jump forward the length of the plist
        this.readPos += msgLength;

        // Calculate how much buffer is left
        var leftOver = this.received.length - this.readPos;

        // Is there some left over?
        if (leftOver !== 0) {
          // Copy what's left over into a new buffer, and save it for next time
          var chunk = new Buffer(leftOver);
          this.received.copy(chunk, 0, this.readPos);
          this.received = chunk;
        } else {
          // Otherwise, empty the buffer and get out of the loop
          this.received = new Buffer(0);
          dataLeftOver = false;
        }

        // Reset the read position
        this.readPos = 0;

        // Now do something with the plist
        if (plist) {
          this.messageHandler.handleMessage(plist);
        }
      }
    }
  }, {
    key: 'setTimelineEventHandler',
    value: function setTimelineEventHandler(timelineEventHandler) {
      this.timelineEventHandler = timelineEventHandler;
      this.messageHandler.setTimelineEventHandler(timelineEventHandler);
    }
  }]);

  return RemoteDebuggerRpcClient;
})();

exports['default'] = RemoteDebuggerRpcClient;
module.exports = exports['default'];

// local callback, temporarily added as callback to
// `_rpc_applicationConnected:` remote debugger response
// to handle the initial connection

// from the dictionary returned, get the ids

// error listener, which needs to be removed after the promise is resolved

// most of the time we don't care when socket.write does
// so give it an empty function
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9yZW1vdGUtZGVidWdnZXItcnBjLWNsaWVudC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztzQkFDZ0IsVUFBVTs7OztzQkFDWixRQUFROzs7OzZCQUNHLGdCQUFnQjs7Ozs0QkFDakIsZUFBZTs7OzswQkFDaEIsWUFBWTs7Ozt3QkFDZixVQUFVOzs7OzhCQUNPLG1CQUFtQjs7d0JBQ3ZDLFdBQVc7Ozs7bUJBQ1osS0FBSzs7Ozs0Q0FDUyxtQ0FBbUM7Ozs7OEJBQ3BDLG1CQUFtQjs7Ozt1QkFDaEIsV0FBVzs7SUFHdEIsdUJBQXVCO0FBQzlCLFdBRE8sdUJBQXVCLENBQzdCLElBQUksRUFBNEQ7UUFBMUQsSUFBSTtRQUF5QixzQkFBc0IseURBQUcsRUFBRTs7MEJBRHhELHVCQUF1Qjs7O0FBR3hDLFFBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO0FBQ25CLFFBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBQ2pCLFFBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBQ2pCLFFBQUksQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO0FBQ3ZCLFFBQUksQ0FBQyxNQUFNLEdBQUcsc0JBQUssRUFBRSxFQUFFLENBQUM7QUFDeEIsUUFBSSxDQUFDLFFBQVEsR0FBRyxzQkFBSyxFQUFFLEVBQUUsQ0FBQztBQUMxQixRQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQztBQUNsQixRQUFJLENBQUMsUUFBUSxHQUFHLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzlCLFFBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDOzs7QUFHakIsUUFBSSxDQUFDLHNCQUFzQixHQUFHLHNCQUFzQixDQUFDO0FBQ3JELFFBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDO0dBQzVCOztlQWhCa0IsdUJBQXVCOztXQWtCNUI7Ozs7OztBQUNaLGdCQUFJLENBQUMsY0FBYyxHQUFHLDhDQUFzQixJQUFJLENBQUMsc0JBQXNCLENBQUMsQ0FBQzs7O0FBR3pFLGdCQUFJLENBQUMsTUFBTSxHQUFHLElBQUksaUJBQUksTUFBTSxDQUFDLEVBQUMsSUFBSSxFQUFFLE1BQU0sRUFBQyxDQUFDLENBQUM7QUFDN0MsZ0JBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzdCLGdCQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsWUFBTTtBQUM1QixrQkFBSSxNQUFLLFNBQVMsRUFBRTtBQUNsQixvQ0FBSSxLQUFLLENBQUMsOEJBQThCLENBQUMsQ0FBQztlQUMzQztBQUNELG9CQUFLLFNBQVMsR0FBRyxLQUFLLENBQUM7QUFDdkIsb0JBQUssTUFBTSxHQUFHLElBQUksQ0FBQzthQUNwQixDQUFDLENBQUM7QUFDSCxnQkFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFLFlBQU07QUFDMUIsb0JBQUssU0FBUyxHQUFHLEtBQUssQ0FBQzthQUN4QixDQUFDLENBQUM7QUFDSCxnQkFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7Ozs7NkNBR25DLDBCQUFZLG9CQUFPLE9BQU8sRUFBRSxNQUFNOzs7Ozs7O0FBRTdDLHdCQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQ3RDLHdCQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxTQUFTLEVBQUU7Ozs7QUFDeEIsZ0RBQUksS0FBSyxtQ0FBaUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxhQUFhLFNBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUcsQ0FBQztBQUNqRyxnQ0FBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUM7O0FBRXRCLG1DQUFPLEVBQUUsQ0FBQzs7Ozs7OztxQkFDWCxDQUFDLENBQUM7QUFDSCx3QkFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLFVBQUMsU0FBUyxFQUFLO0FBQ3JDLDBCQUFJLE9BQUssU0FBUyxFQUFFO0FBQ2xCLDRDQUFJLEtBQUssb0JBQWtCLFNBQVMsQ0FBQyxPQUFPLENBQUcsQ0FBQztBQUNoRCwrQkFBSyxTQUFTLEdBQUcsS0FBSyxDQUFDO3VCQUN4Qjs7O0FBR0QsNEJBQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQztxQkFDbkIsQ0FBQyxDQUFDOzs7Ozs7O2FBQ0osQ0FBQzs7Ozs7Ozs7OztLQUNIOzs7V0FFZ0I7Ozs7QUFDZixnQkFBSSxJQUFJLENBQUMsV0FBVyxFQUFFLEVBQUU7QUFDdEIsa0NBQUksS0FBSyxDQUFDLG9DQUFvQyxDQUFDLENBQUM7QUFDaEQsa0JBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFLENBQUM7YUFDdkI7QUFDRCxnQkFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7Ozs7Ozs7S0FDeEI7OztXQUVXLHVCQUFHO0FBQ2IsYUFBTyxJQUFJLENBQUMsU0FBUyxDQUFDO0tBQ3ZCOzs7V0FFd0Isa0NBQUMsR0FBRyxFQUFFLFlBQVksRUFBRSxPQUFPLEVBQUU7QUFDcEQsVUFBSSxDQUFDLGNBQWMsQ0FBQyx3QkFBd0IsQ0FBQyxHQUFHLEVBQUUsWUFBWSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0tBQzFFOzs7V0FFd0Isa0NBQUMsR0FBRyxFQUFFO0FBQzdCLGFBQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyx3QkFBd0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUMxRDs7O1dBRXFCLCtCQUFDLEdBQUcsRUFBRSxZQUFZLEVBQUUsT0FBTyxFQUFFO0FBQ2pELFVBQUksQ0FBQyxjQUFjLENBQUMscUJBQXFCLENBQUMsR0FBRyxFQUFFLFlBQVksRUFBRSxPQUFPLENBQUMsQ0FBQztLQUN2RTs7O1dBRTRCLHdDQUFlO1VBQWQsS0FBSyx5REFBRyxJQUFJOztBQUN4QyxVQUFJLENBQUMsY0FBYyxDQUFDLDRCQUE0QixDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQ3pEOzs7V0FFZSxtQkFBQyxRQUFRLEVBQUUsMkJBQTJCOzs7Ozs7OzZDQUN2QywwQkFBWSxvQkFBTyxPQUFPLEVBQUUsTUFBTTtrQkFJekMsV0FBVyxlQWtCVixpQkFBaUIsRUFBRSxRQUFRLEVBTzFCLEdBQUc7Ozs7Ozs7QUF6QkwsK0JBQVcsR0FBRyxTQUFkLFdBQVcsQ0FBVSxJQUFJOzBCQUV2QixXQUFXLEVBQ1gsZUFBZTs7OztBQURmLHVDQUFXLEdBQUcsSUFBSSxDQUFDLCtCQUErQjtBQUNsRCwyQ0FBZSxHQUFHLElBQUksQ0FBQywyQkFBMkI7Ozs7QUFJdEQsZ0NBQUksV0FBVyxJQUFJLGVBQWUsS0FBSyxXQUFXLEVBQUU7QUFDbEQsa0RBQUksS0FBSyxDQUFDLCtFQUNZLGVBQWUsb0JBQWUsV0FBVyxDQUFFLENBQUMsQ0FBQzs2QkFDcEU7O0FBRUQsdURBQTJCLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDbEMsa0NBQU0sQ0FBQywrQkFBK0IsQ0FBQyxDQUFDOzs7Ozs7O3FCQUN6Qzs7QUFDRCx3QkFBSSxDQUFDLHdCQUF3QixDQUFDLDRCQUE0QixFQUFFLE1BQU0sRUFBRSxXQUFXLENBQUMsQ0FBQzs7OztxREFHdkMsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLEVBQUU7QUFDbEUsOEJBQVEsRUFBUixRQUFRO3FCQUNULENBQUM7Ozs7O0FBRkcscUNBQWlCO0FBQUUsNEJBQVE7Ozs7QUFNaEMsd0JBQUksb0JBQUUsT0FBTyxDQUFDLFFBQVEsQ0FBQyxFQUFFO0FBQ25CLHlCQUFHLEdBQUcsZ0NBQWdDOztBQUMxQywwQ0FBSSxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDZiw0QkFBTSxDQUFDLElBQUksS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7cUJBQ3hCLE1BQU07QUFDTCw2QkFBTyxDQUFDLENBQUMsaUJBQWlCLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQztxQkFDeEM7Ozs7Ozs7YUFDRixDQUFDLFdBQVEsQ0FBQyxZQUFNOztBQUVmLHFCQUFLLHdCQUF3QixDQUFDLDRCQUE0QixFQUFFLElBQUksRUFBRSwyQkFBMkIsQ0FBQyxDQUFDO2FBQ2hHLENBQUM7Ozs7Ozs7Ozs7S0FDSDs7O1dBRVUsY0FBQyxPQUFPO1VBQUUsSUFBSSx5REFBRyxFQUFFO1VBRXhCLGFBQWE7Ozs7OztBQUFiLHlCQUFhOzs2Q0FFSiwwQkFBWSxvQkFBTyxPQUFPLEVBQUUsTUFBTTtrQkFNekMsSUFBSSxFQUlKLFFBQVEsRUFrRFIsS0FBSyxFQWtCSCxHQUFHOzs7Ozs7Ozs7O0FBekVULHdCQUFJLEdBQUcsb0JBQUUsUUFBUSxDQUFDLEVBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNwRSx3QkFBSSxHQUFHLGlDQUFpQixPQUFPLEVBQUUsSUFBSSxDQUFDO0FBSXRDLDRCQUFRLEdBQUcsb0JBQUUsSUFBSTs7O0FBR3JCLGlDQUFhLEdBQUcsVUFBQyxTQUFTLEVBQUs7QUFDN0IsMEJBQUksT0FBSyxTQUFTLEVBQUU7QUFDbEIsNENBQUksS0FBSyxvQkFBa0IsU0FBUyxDQUFDLE9BQU8sQ0FBRyxDQUFDO3VCQUNqRDs7O0FBR0QsNEJBQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQztxQkFDbkIsQ0FBQztBQUNGLHdCQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsYUFBYSxDQUFDLENBQUM7QUFDdkMsd0JBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyx3QkFBd0IsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUU7Ozs7QUFHakUsNEJBQUkscUJBQXFCLEdBQUcsT0FBSyx3QkFBd0IsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDM0UsK0JBQUssd0JBQXdCLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxNQUFNLEVBQUUsQ0FBQSxZQUFtQjs0REFBTixJQUFJO0FBQUosZ0NBQUk7OztBQUN0RSw4Q0FBSSxLQUFLLDRDQUF5QyxvQkFBRSxRQUFRLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFDLE1BQU0sRUFBRSxFQUFFLEVBQUMsQ0FBQyxRQUFJLENBQUM7OztBQUdyRywrQ0FBcUIsa0JBQUksSUFBSSxDQUFDLENBQUM7QUFDL0IsOEJBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyx3QkFBd0IsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUU7O0FBRWpFLGdDQUFJLENBQUMsd0JBQXdCLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxJQUFJLEVBQUUscUJBQXFCLENBQUMsQ0FBQzsyQkFDN0U7O0FBRUQsaUNBQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQzt5QkFDZixDQUFBLENBQUMsSUFBSSxRQUFNLENBQUMsQ0FBQzs7cUJBQ2YsTUFBTSxJQUFJLElBQUksQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsRUFBRTs7O0FBRzlELDBCQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7QUFDaEIsMEJBQUksQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxFQUFFLE1BQU0sRUFBRSxVQUFDLEtBQUssRUFBSztBQUN0RSw0QkFBSSxHQUFHLEdBQUcsb0JBQUUsUUFBUSxDQUFDLG9CQUFFLFFBQVEsQ0FBQyxLQUFLLENBQUMsR0FBRyxLQUFLLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFDLE1BQU0sRUFBRSxFQUFFLEVBQUMsQ0FBQyxDQUFDO0FBQ3RGLDRDQUFJLEtBQUssaURBQThDLEdBQUcsUUFBSSxDQUFDO0FBQy9ELDRDQUFJLEtBQUssd0JBQXNCLE9BQU8sQ0FBRyxDQUFDO0FBQzFDLCtCQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7dUJBQ2hCLENBQUMsQ0FBQztBQUNILDBCQUFJLENBQUMsVUFBVSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO0FBQ3BELDBCQUFJLENBQUMsVUFBVSxDQUFDLGdCQUFnQixHQUM1QixJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDO3FCQUNsRSxNQUFNOzs7QUFHTCw4QkFBUSxHQUFHLE9BQU8sQ0FBQztxQkFDcEI7O0FBRUQsd0NBQUksS0FBSyxnQkFBYSxJQUFJLENBQUMsVUFBVSxtQ0FBK0IsQ0FBQzs7O0FBR2pFLHlCQUFLOzs7QUFFUCx5QkFBSyxHQUFHLGdDQUFhLElBQUksQ0FBQyxDQUFDOzs7Ozs7O0FBRXZCLHVCQUFHLGlEQUErQyxlQUFFLE9BQU87O0FBQy9ELHdDQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQzt3REFDUixNQUFNLENBQUMsSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7Ozs7QUFHL0Isd0JBQUksSUFBSSxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFOzs7O0FBSWpDLDBCQUFJLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDO0FBQ25CLDBCQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyx3QkFBVyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN4RCwwQkFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0FBQ25DLDBCQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDO3FCQUN0QixNQUFNO0FBQ0QseUJBQUcsR0FBRyx3REFBd0Q7O0FBQ2xFLDBDQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNmLDRCQUFNLENBQUMsSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztxQkFDeEI7Ozs7Ozs7YUFDRixDQUFDLFdBQVEsQ0FBQyxZQUFNOztBQUVmLHFCQUFLLE1BQU0sQ0FBQyxjQUFjLENBQUMsT0FBTyxFQUFFLGFBQWEsQ0FBQyxDQUFDO2FBQ3BELENBQUM7Ozs7Ozs7Ozs7S0FDSDs7O1dBRU8saUJBQUMsSUFBSSxFQUFFOztBQUViLFVBQUksQ0FBQyxRQUFRLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUNyRCxVQUFJLFlBQVksR0FBRyxJQUFJLENBQUM7OztBQUd4QixhQUFPLFlBQVksRUFBRTs7QUFFbkIsWUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQzs7OztBQUk5QixZQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUM7O0FBRWpFLFlBQUksU0FBUyxZQUFBLENBQUM7QUFDZCxZQUFJO0FBQ0YsbUJBQVMsR0FBRyx3QkFBVyxNQUFNLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQy9DLENBQUMsT0FBTyxDQUFDLEVBQUU7QUFDViw4QkFBSSxLQUFLLCtCQUE2QixDQUFDLENBQUcsQ0FBQztBQUMzQyxpQkFBTztTQUNSOzs7QUFHRCxZQUFJLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQzs7OztBQUlsQixZQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLFNBQVMsR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFO0FBQ25ELGNBQUksQ0FBQyxPQUFPLEdBQUcsVUFBVSxDQUFDO0FBQzFCLGdCQUFNO1NBQ1A7OztBQUdELFlBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsU0FBUyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQzs7O0FBR3ZFLFlBQUksS0FBSyxZQUFBLENBQUM7QUFDVixZQUFJO0FBQ0YsZUFBSyxHQUFHLDBCQUFZLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUN2QyxDQUFDLE9BQU8sQ0FBQyxFQUFFO0FBQ1YsOEJBQUksS0FBSyxrQ0FBZ0MsQ0FBQyxDQUFHLENBQUM7QUFDOUMsaUJBQU87U0FDUjs7O0FBR0QsWUFBSSxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtBQUN0QixlQUFLLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ2xCOzttQkFFZSxDQUFDLG1CQUFtQixFQUFFLG1CQUFtQixFQUFFLGtCQUFrQixDQUFDO0FBQTlFLGlEQUFnRjtBQUEzRSxjQUFJLEdBQUcsV0FBQSxDQUFBO0FBQ1YsY0FBSSxDQUFDLG9CQUFFLFdBQVcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtBQUM5QixpQkFBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7V0FDMUM7U0FDRjs7QUFFRCxZQUFJLEtBQUssQ0FBQyxVQUFVLEtBQUssMkJBQTJCLEVBQUU7QUFDcEQsOEJBQUksS0FBSyxDQUFDLHVDQUF1QyxDQUFDLENBQUM7U0FDcEQsTUFBTTtBQUNMLDhCQUFJLEtBQUssNkNBQTBDLDhCQUFnQixLQUFLLENBQUMsUUFBSSxDQUFDO1NBQy9FOzs7QUFHRCxZQUFJLENBQUMsT0FBTyxJQUFJLFNBQVMsQ0FBQzs7O0FBRzFCLFlBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7OztBQUduRCxZQUFJLFFBQVEsS0FBSyxDQUFDLEVBQUU7O0FBRWxCLGNBQUksS0FBSyxHQUFHLElBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ2pDLGNBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzNDLGNBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDO1NBQ3ZCLE1BQU07O0FBRUwsY0FBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM5QixzQkFBWSxHQUFHLEtBQUssQ0FBQztTQUN0Qjs7O0FBR0QsWUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUM7OztBQUdqQixZQUFJLEtBQUssRUFBRTtBQUNULGNBQUksQ0FBQyxjQUFjLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQzFDO09BQ0Y7S0FDRjs7O1dBRXVCLGlDQUFDLG9CQUFvQixFQUFFO0FBQzdDLFVBQUksQ0FBQyxvQkFBb0IsR0FBRyxvQkFBb0IsQ0FBQztBQUNqRCxVQUFJLENBQUMsY0FBYyxDQUFDLHVCQUF1QixDQUFDLG9CQUFvQixDQUFDLENBQUM7S0FDbkU7OztTQXhUa0IsdUJBQXVCOzs7cUJBQXZCLHVCQUF1QiIsImZpbGUiOiJsaWIvcmVtb3RlLWRlYnVnZ2VyLXJwYy1jbGllbnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBqc2hpbnQgaWdub3JlOiBzdGFydFxuaW1wb3J0IGxvZyBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IGJwbGlzdENyZWF0ZSBmcm9tICdicGxpc3QtY3JlYXRvcic7XG5pbXBvcnQgYnBsaXN0UGFyc2UgZnJvbSAnYnBsaXN0LXBhcnNlcic7XG5pbXBvcnQgYnVmZmVycGFjayBmcm9tICdidWZmZXJwYWNrJztcbmltcG9ydCBQcm9taXNlIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB7IFJFTU9URV9ERUJVR0dFUl9QT1JUIH0gZnJvbSAnLi9yZW1vdGUtZGVidWdnZXInO1xuaW1wb3J0IHV1aWQgZnJvbSAnbm9kZS11dWlkJztcbmltcG9ydCBuZXQgZnJvbSAnbmV0JztcbmltcG9ydCBScGNNZXNzYWdlSGFuZGxlciBmcm9tICcuL3JlbW90ZS1kZWJ1Z2dlci1tZXNzYWdlLWhhbmRsZXInO1xuaW1wb3J0IGdldFJlbW90ZUNvbW1hbmQgZnJvbSAnLi9yZW1vdGUtbWVzc2FnZXMnO1xuaW1wb3J0IHsgc2ltcGxlU3RyaW5naWZ5IH0gZnJvbSAnLi9oZWxwZXJzJztcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW1vdGVEZWJ1Z2dlclJwY0NsaWVudCB7XG4gIGNvbnN0cnVjdG9yIChob3N0LCBwb3J0ID0gUkVNT1RFX0RFQlVHR0VSX1BPUlQsIHNwZWNpYWxNZXNzYWdlSGFuZGxlcnMgPSB7fSkge1xuICAgIC8vIHNvY2tldCBhbmQgY29ubmVjdGlvbiBjb25maWd1cmF0aW9uXG4gICAgdGhpcy5zb2NrZXQgPSBudWxsO1xuICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgdGhpcy5wb3J0ID0gcG9ydDtcbiAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuY29ubklkID0gdXVpZC52NCgpO1xuICAgIHRoaXMuc2VuZGVySWQgPSB1dWlkLnY0KCk7XG4gICAgdGhpcy5jdXJNc2dJZCA9IDA7XG4gICAgdGhpcy5yZWNlaXZlZCA9IG5ldyBCdWZmZXIoMCk7XG4gICAgdGhpcy5yZWFkUG9zID0gMDtcblxuICAgIC8vIG1lc3NhZ2UgaGFuZGxlcnNcbiAgICB0aGlzLnNwZWNpYWxNZXNzYWdlSGFuZGxlcnMgPSBzcGVjaWFsTWVzc2FnZUhhbmRsZXJzO1xuICAgIHRoaXMubWVzc2FnZUhhbmRsZXIgPSBudWxsO1xuICB9XG5cbiAgYXN5bmMgY29ubmVjdCAoKSB7XG4gICAgdGhpcy5tZXNzYWdlSGFuZGxlciA9IG5ldyBScGNNZXNzYWdlSGFuZGxlcih0aGlzLnNwZWNpYWxNZXNzYWdlSGFuZGxlcnMpO1xuXG4gICAgLy8gY3JlYXRlIHNvY2tldCBhbmQgaGFuZGxlIGl0cyBtZXNzYWdlc1xuICAgIHRoaXMuc29ja2V0ID0gbmV3IG5ldC5Tb2NrZXQoe3R5cGU6ICd0Y3A2J30pO1xuICAgIHRoaXMuc29ja2V0LnNldE5vRGVsYXkodHJ1ZSk7XG4gICAgdGhpcy5zb2NrZXQub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgIGxvZy5kZWJ1ZygnRGVidWdnZXIgc29ja2V0IGRpc2Nvbm5lY3RlZCcpO1xuICAgICAgfVxuICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuc29ja2V0ID0gbnVsbDtcbiAgICB9KTtcbiAgICB0aGlzLnNvY2tldC5vbignZW5kJywgKCkgPT4ge1xuICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB9KTtcbiAgICB0aGlzLnNvY2tldC5vbignZGF0YScsIHRoaXMucmVjZWl2ZS5iaW5kKHRoaXMpKTtcblxuICAgIC8vIGNvbm5lY3QgdGhlIHNvY2tldFxuICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBvbmx5IHJlc29sdmUgdGhpcyBmdW5jdGlvbiB3aGVuIHdlIGFyZSBhY3R1YWxseSBjb25uZWN0ZWRcbiAgICAgIHRoaXMuc29ja2V0LmNvbm5lY3QodGhpcy5wb3J0LCAnOjoxJyk7XG4gICAgICB0aGlzLnNvY2tldC5vbignY29ubmVjdCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgbG9nLmRlYnVnKGBEZWJ1Z2dlciBzb2NrZXQgY29ubmVjdGVkIHRvICR7dGhpcy5zb2NrZXQucmVtb3RlQWRkcmVzc306JHt0aGlzLnNvY2tldC5yZW1vdGVQb3J0fWApO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG5cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNvY2tldC5vbignZXJyb3InLCAoZXhjZXB0aW9uKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgIGxvZy5lcnJvcihgU29ja2V0IGVycm9yOiAke2V4Y2VwdGlvbi5tZXNzYWdlfWApO1xuICAgICAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgY29ubmVjdGlvbiB3YXMgcmVmdXNlZCwgc28gcmVqZWN0IHRoZSBjb25uZWN0IHByb21pc2VcbiAgICAgICAgcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGRpc2Nvbm5lY3QgKCkge1xuICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgIGxvZy5kZWJ1ZygnRGlzY29ubmVjdGluZyBmcm9tIHJlbW90ZSBkZWJ1Z2dlcicpO1xuICAgICAgdGhpcy5zb2NrZXQuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICB9XG5cbiAgaXNDb25uZWN0ZWQgKCkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3RlZDtcbiAgfVxuXG4gIHNldFNwZWNpYWxNZXNzYWdlSGFuZGxlciAoa2V5LCBlcnJvckhhbmRsZXIsIGhhbmRsZXIpIHtcbiAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNldFNwZWNpYWxNZXNzYWdlSGFuZGxlcihrZXksIGVycm9ySGFuZGxlciwgaGFuZGxlcik7XG4gIH1cblxuICBnZXRTcGVjaWFsTWVzc2FnZUhhbmRsZXIgKGtleSkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLmdldFNwZWNpYWxNZXNzYWdlSGFuZGxlcihrZXkpO1xuICB9XG5cbiAgc2V0RGF0YU1lc3NhZ2VIYW5kbGVyIChrZXksIGVycm9ySGFuZGxlciwgaGFuZGxlcikge1xuICAgIHRoaXMubWVzc2FnZUhhbmRsZXIuc2V0RGF0YU1lc3NhZ2VIYW5kbGVyKGtleSwgZXJyb3JIYW5kbGVyLCBoYW5kbGVyKTtcbiAgfVxuXG4gIGFsbG93TmF2aWdhdGlvbldpdGhvdXRSZWxvYWQgKGFsbG93ID0gdHJ1ZSkge1xuICAgIHRoaXMubWVzc2FnZUhhbmRsZXIuYWxsb3dOYXZpZ2F0aW9uV2l0aG91dFJlbG9hZChhbGxvdyk7XG4gIH1cblxuICBhc3luYyBzZWxlY3RBcHAgKGFwcElkS2V5LCBhcHBsaWNhdGlvbkNvbm5lY3RlZEhhbmRsZXIpIHtcbiAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgLy8gbG9jYWwgY2FsbGJhY2ssIHRlbXBvcmFyaWx5IGFkZGVkIGFzIGNhbGxiYWNrIHRvXG4gICAgICAvLyBgX3JwY19hcHBsaWNhdGlvbkNvbm5lY3RlZDpgIHJlbW90ZSBkZWJ1Z2dlciByZXNwb25zZVxuICAgICAgLy8gdG8gaGFuZGxlIHRoZSBpbml0aWFsIGNvbm5lY3Rpb25cbiAgICAgIGxldCBvbkFwcENoYW5nZSA9IGFzeW5jIChkaWN0KSA9PiB7XG4gICAgICAgIC8vIGZyb20gdGhlIGRpY3Rpb25hcnkgcmV0dXJuZWQsIGdldCB0aGUgaWRzXG4gICAgICAgIGxldCBvbGRBcHBJZEtleSA9IGRpY3QuV0lSSG9zdEFwcGxpY2F0aW9uSWRlbnRpZmllcktleTtcbiAgICAgICAgbGV0IGNvcnJlY3RBcHBJZEtleSA9IGRpY3QuV0lSQXBwbGljYXRpb25JZGVudGlmaWVyS2V5O1xuXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYSByZXBvcnQgb2YgYSBwcm94eSByZWRpcmVjdCBmcm9tIHRoZSByZW1vdGUgZGVidWdnZXJcbiAgICAgICAgLy8gd2Ugd2FudCB0byB1cGRhdGUgb3VyIGRpY3Rpb25hcnkgYW5kIGdldCBhIG5ldyBhcHAgaWRcbiAgICAgICAgaWYgKG9sZEFwcElkS2V5ICYmIGNvcnJlY3RBcHBJZEtleSAhPT0gb2xkQXBwSWRLZXkpIHtcbiAgICAgICAgICBsb2cuZGVidWcoYFdlIHdlcmUgbm90aWZpZWQgd2UgbWlnaHQgaGF2ZSBjb25uZWN0ZWQgdG8gdGhlIHdyb25nIGFwcC4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBVc2luZyBpZCAke2NvcnJlY3RBcHBJZEtleX0gaW5zdGVhZCBvZiAke29sZEFwcElkS2V5fWApO1xuICAgICAgICB9XG5cbiAgICAgICAgYXBwbGljYXRpb25Db25uZWN0ZWRIYW5kbGVyKGRpY3QpO1xuICAgICAgICByZWplY3QoJ05ldyBhcHBsaWNhdGlvbiBoYXMgY29ubmVjdGVkJyk7XG4gICAgICB9O1xuICAgICAgdGhpcy5zZXRTcGVjaWFsTWVzc2FnZUhhbmRsZXIoJ19ycGNfYXBwbGljYXRpb25Db25uZWN0ZWQ6JywgcmVqZWN0LCBvbkFwcENoYW5nZSk7XG5cbiAgICAgIC8vIGRvIHRoZSBhY3R1YWwgY29ubmVjdGluZyB0byB0aGUgYXBwXG4gICAgICBsZXQgW2Nvbm5lY3RlZEFwcElkS2V5LCBwYWdlRGljdF0gPSBhd2FpdCB0aGlzLnNlbmQoJ2Nvbm5lY3RUb0FwcCcsIHtcbiAgICAgICAgYXBwSWRLZXlcbiAgICAgIH0pO1xuXG4gICAgICAvLyBzb21ldGltZXMgdGhlIGNvbm5lY3QgbG9naWMgaGFwcGVucywgYnV0IHdpdGggYW4gZW1wdHkgZGljdGlvbmFyeVxuICAgICAgLy8gd2hpY2ggbGVhZHMgdG8gdGhlIHJlbW90ZSBkZWJ1Z2dlciBnZXR0aW5nIGRpc2Nvbm5lY3RlZCwgYW5kIGludG8gYSBsb29wXG4gICAgICBpZiAoXy5pc0VtcHR5KHBhZ2VEaWN0KSkge1xuICAgICAgICBsZXQgbXNnID0gJ0VtcHR5IHBhZ2UgZGljdGlvbmFyeSByZWNlaXZlZCc7XG4gICAgICAgIGxvZy5kZWJ1Zyhtc2cpO1xuICAgICAgICByZWplY3QobmV3IEVycm9yKG1zZykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZShbY29ubmVjdGVkQXBwSWRLZXksIHBhZ2VEaWN0XSk7XG4gICAgICB9XG4gICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAvLyBubyBtYXR0ZXIgd2hhdCwgd2Ugd2FudCB0byByZXN0b3JlIHRoZSBoYW5kbGVyIHRoYXQgd2FzIGNoYW5nZWQuXG4gICAgICB0aGlzLnNldFNwZWNpYWxNZXNzYWdlSGFuZGxlcignX3JwY19hcHBsaWNhdGlvbkNvbm5lY3RlZDonLCBudWxsLCBhcHBsaWNhdGlvbkNvbm5lY3RlZEhhbmRsZXIpO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgc2VuZCAoY29tbWFuZCwgb3B0cyA9IHt9KSB7XG4gICAgLy8gZXJyb3IgbGlzdGVuZXIsIHdoaWNoIG5lZWRzIHRvIGJlIHJlbW92ZWQgYWZ0ZXIgdGhlIHByb21pc2UgaXMgcmVzb2x2ZWRcbiAgICBsZXQgb25Tb2NrZXRFcnJvcjtcblxuICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBwcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW5ldmVyIHJlbW90ZSBkZWJ1Z2dlclxuICAgICAgLy8gcmVwbGllcyB0byBvdXIgcmVxdWVzdFxuXG4gICAgICAvLyByZXRyaWV2ZSB0aGUgY29ycmVjdCBjb21tYW5kIHRvIHNlbmRcbiAgICAgIG9wdHMgPSBfLmRlZmF1bHRzKHtjb25uSWQ6IHRoaXMuY29ubklkLCBzZW5kZXJJZDogdGhpcy5zZW5kZXJJZH0sIG9wdHMpO1xuICAgICAgbGV0IGRhdGEgPSBnZXRSZW1vdGVDb21tYW5kKGNvbW1hbmQsIG9wdHMpO1xuXG4gICAgICAvLyBtb3N0IG9mIHRoZSB0aW1lIHdlIGRvbid0IGNhcmUgd2hlbiBzb2NrZXQud3JpdGUgZG9lc1xuICAgICAgLy8gc28gZ2l2ZSBpdCBhbiBlbXB0eSBmdW5jdGlvblxuICAgICAgbGV0IHNvY2tldENiID0gXy5ub29wO1xuXG4gICAgICAvLyBoYW5kbGUgc29ja2V0IHByb2JsZW1zXG4gICAgICBvblNvY2tldEVycm9yID0gKGV4Y2VwdGlvbikgPT4ge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICBsb2cuZXJyb3IoYFNvY2tldCBlcnJvcjogJHtleGNlcHRpb24ubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZSBjb25uZWN0aW9uIHdhcyByZWZ1c2VkLCBzbyByZWplY3QgdGhlIGNvbm5lY3QgcHJvbWlzZVxuICAgICAgICByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgIH07XG4gICAgICB0aGlzLnNvY2tldC5vbignZXJyb3InLCBvblNvY2tldEVycm9yKTtcbiAgICAgIGlmICh0aGlzLm1lc3NhZ2VIYW5kbGVyLmhhc1NwZWNpYWxNZXNzYWdlSGFuZGxlcihkYXRhLl9fc2VsZWN0b3IpKSB7XG4gICAgICAgIC8vIHNwZWNpYWwgcmVwbGllcyB3aWxsIHJldHVybiBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICAgICAgICAvLyB0ZW1wb3JhcmlseSB3cmFwIHdpdGggcHJvbWlzZSBoYW5kbGluZ1xuICAgICAgICBsZXQgc3BlY2lhbE1lc3NhZ2VIYW5kbGVyID0gdGhpcy5nZXRTcGVjaWFsTWVzc2FnZUhhbmRsZXIoZGF0YS5fX3NlbGVjdG9yKTtcbiAgICAgICAgdGhpcy5zZXRTcGVjaWFsTWVzc2FnZUhhbmRsZXIoZGF0YS5fX3NlbGVjdG9yLCByZWplY3QsIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgbG9nLmRlYnVnKGBSZWNlaXZlZCByZXNwb25zZSBmcm9tIHNvY2tldCBzZW5kOiAnJHtfLnRydW5jYXRlKEpTT04uc3RyaW5naWZ5KGFyZ3MpLCB7bGVuZ3RoOiA1MH0pfSdgKTtcblxuICAgICAgICAgIC8vIGNhbGwgdGhlIG9yaWdpbmFsIGxpc3RlbmVyLCBhbmQgcHV0IGl0IGJhY2ssIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgIHNwZWNpYWxNZXNzYWdlSGFuZGxlciguLi5hcmdzKTtcbiAgICAgICAgICBpZiAodGhpcy5tZXNzYWdlSGFuZGxlci5oYXNTcGVjaWFsTWVzc2FnZUhhbmRsZXIoZGF0YS5fX3NlbGVjdG9yKSkge1xuICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGF0IHRoZSBzeXN0ZW0gaGFzIG5vdCByZW1vdmVkIHRoaXMgbGlzdGVuZXJcbiAgICAgICAgICAgIHRoaXMuc2V0U3BlY2lhbE1lc3NhZ2VIYW5kbGVyKGRhdGEuX19zZWxlY3RvciwgbnVsbCwgc3BlY2lhbE1lc3NhZ2VIYW5kbGVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXNvbHZlKGFyZ3MpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLl9fYXJndW1lbnQgJiYgZGF0YS5fX2FyZ3VtZW50LldJUlNvY2tldERhdGFLZXkpIHtcbiAgICAgICAgLy8ga2VlcCB0cmFjayBvZiB0aGUgbWVzc2FnZXMgY29taW5nIGFuZCBnb2luZyB1c2luZ1xuICAgICAgICAvLyBhIHNpbXBsZSBzZXF1ZW50aWFsIGlkXG4gICAgICAgIHRoaXMuY3VyTXNnSWQrKztcbiAgICAgICAgdGhpcy5zZXREYXRhTWVzc2FnZUhhbmRsZXIodGhpcy5jdXJNc2dJZC50b1N0cmluZygpLCByZWplY3QsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgIGxldCBtc2cgPSBfLnRydW5jYXRlKF8uaXNTdHJpbmcodmFsdWUpID8gdmFsdWUgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSksIHtsZW5ndGg6IDUwfSk7XG4gICAgICAgICAgbG9nLmRlYnVnKGBSZWNlaXZlZCBkYXRhIHJlc3BvbnNlIGZyb20gc29ja2V0IHNlbmQ6ICcke21zZ30nYCk7XG4gICAgICAgICAgbG9nLmRlYnVnKGBPcmlnaW5hbCBjb21tYW5kOiAke2NvbW1hbmR9YCk7XG4gICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkYXRhLl9fYXJndW1lbnQuV0lSU29ja2V0RGF0YUtleS5pZCA9IHRoaXMuY3VyTXNnSWQ7XG4gICAgICAgIGRhdGEuX19hcmd1bWVudC5XSVJTb2NrZXREYXRhS2V5ID1cbiAgICAgICAgICAgIG5ldyBCdWZmZXIoSlNPTi5zdHJpbmdpZnkoZGF0YS5fX2FyZ3VtZW50LldJUlNvY2tldERhdGFLZXkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdlIHdhbnQgdG8gaW1tZWRpYXRlbHkgcmVzb2x2ZSB0aGlzIHNvY2tldC53cml0ZVxuICAgICAgICAvLyBhbnkgbG9uZyB0ZXJtIGNhbGxiYWNrcyB3aWxsIGRvIHRoZWlyIGJ1c2luZXNzIGluIHRoZSBiYWNrZ3JvdW5kXG4gICAgICAgIHNvY2tldENiID0gcmVzb2x2ZTtcbiAgICAgIH1cblxuICAgICAgbG9nLmRlYnVnKGBTZW5kaW5nICcke2RhdGEuX19zZWxlY3Rvcn0nIG1lc3NhZ2UgdG8gcmVtb3RlIGRlYnVnZ2VyYCk7XG5cbiAgICAgIC8vIHJlbW90ZSBkZWJ1Z2dlciBleHBlY3RzIGEgYmluYXJ5IHBsaXN0IGFzIGRhdGFcbiAgICAgIGxldCBwbGlzdDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBsaXN0ID0gYnBsaXN0Q3JlYXRlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsZXQgbXNnID0gYENvdWxkIG5vdCBjcmVhdGUgYmluYXJ5IHBsaXN0IGZyb20gZGF0YTogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgbG9nLmVycm9yKG1zZyk7XG4gICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKG1zZykpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zb2NrZXQgJiYgdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgLy8gY29yayBhbmQgdW5jb3JrIGluIG9yZGVyIHRvIG5vdCBidWZmZXIgdGhlIHdyaXRlXG4gICAgICAgIC8vIG9uIHNvbWUgc3lzdGVtcyB0aGlzIGlzIG5lY2Vzc2FyeSBvciB0aGUgc2VydmVyXG4gICAgICAgIC8vIGdldHMgY29uZnVzZWQuXG4gICAgICAgIHRoaXMuc29ja2V0LmNvcmsoKTtcbiAgICAgICAgdGhpcy5zb2NrZXQud3JpdGUoYnVmZmVycGFjay5wYWNrKCdMJywgW3BsaXN0Lmxlbmd0aF0pKTtcbiAgICAgICAgdGhpcy5zb2NrZXQud3JpdGUocGxpc3QsIHNvY2tldENiKTtcbiAgICAgICAgdGhpcy5zb2NrZXQudW5jb3JrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgbXNnID0gJ0F0dGVtcHRlZCB0byB3cml0ZSBkYXRhIHRvIHNvY2tldCBhZnRlciBpdCB3YXMgY2xvc2VkISc7XG4gICAgICAgIGxvZy5lcnJvcihtc2cpO1xuICAgICAgICByZWplY3QobmV3IEVycm9yKG1zZykpO1xuICAgICAgfVxuICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgLy8gcmVtb3ZlIHRoaXMgbGlzdGVuZXIsIHNvIHdlIGRvbid0IGV4aGF1c3QgdGhlIHN5c3RlbVxuICAgICAgdGhpcy5zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25Tb2NrZXRFcnJvcik7XG4gICAgfSk7XG4gIH1cblxuICByZWNlaXZlIChkYXRhKSB7XG4gICAgLy8gQXBwZW5kIHRoaXMgbmV3IGRhdGEgdG8gdGhlIGV4aXN0aW5nIEJ1ZmZlclxuICAgIHRoaXMucmVjZWl2ZWQgPSBCdWZmZXIuY29uY2F0KFt0aGlzLnJlY2VpdmVkLCBkYXRhXSk7XG4gICAgbGV0IGRhdGFMZWZ0T3ZlciA9IHRydWU7XG5cbiAgICAvLyBQYXJzZSBtdWx0aXBsZSBtZXNzYWdlcyBpbiB0aGUgc2FtZSBwYWNrZXRcbiAgICB3aGlsZSAoZGF0YUxlZnRPdmVyKSB7XG4gICAgICAvLyBTdG9yZSBhIHJlZmVyZW5jZSB0byB3aGVyZSB3ZSB3ZXJlXG4gICAgICBsZXQgb2xkUmVhZFBvcyA9IHRoaXMucmVhZFBvcztcblxuICAgICAgLy8gUmVhZCB0aGUgcHJlZml4IChwbGlzdCBsZW5ndGgpIHRvIHNlZSBob3cgZmFyIHRvIHJlYWQgbmV4dFxuICAgICAgLy8gSXQncyBhbHdheXMgNCBieXRlcyBsb25nXG4gICAgICBsZXQgcHJlZml4ID0gdGhpcy5yZWNlaXZlZC5zbGljZSh0aGlzLnJlYWRQb3MsIHRoaXMucmVhZFBvcyArIDQpO1xuXG4gICAgICBsZXQgbXNnTGVuZ3RoO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXNnTGVuZ3RoID0gYnVmZmVycGFjay51bnBhY2soJ0wnLCBwcmVmaXgpWzBdO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2cuZXJyb3IoYEJ1ZmZlciBjb3VsZCBub3QgdW5wYWNrOiAke2V9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSnVtcCBmb3J3YXJkIDQgYnl0ZXNcbiAgICAgIHRoaXMucmVhZFBvcyArPSA0O1xuXG4gICAgICAvLyBJcyB0aGVyZSBlbm91Z2ggZGF0YSBoZXJlP1xuICAgICAgLy8gSWYgbm90LCBqdW1wIGJhY2sgdG8gb3VyIG9yaWdpbmFsIHBvc2l0aW9uIGFuZCBndGZvXG4gICAgICBpZiAodGhpcy5yZWNlaXZlZC5sZW5ndGggPCBtc2dMZW5ndGggKyB0aGlzLnJlYWRQb3MpIHtcbiAgICAgICAgdGhpcy5yZWFkUG9zID0gb2xkUmVhZFBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIEV4dHJhY3QgdGhlIG1haW4gYm9keSBvZiB0aGUgbWVzc2FnZSAod2hlcmUgdGhlIHBsaXN0IHNob3VsZCBiZSlcbiAgICAgIGxldCBib2R5ID0gdGhpcy5yZWNlaXZlZC5zbGljZSh0aGlzLnJlYWRQb3MsIG1zZ0xlbmd0aCArIHRoaXMucmVhZFBvcyk7XG5cbiAgICAgIC8vIEV4dHJhY3QgdGhlIHBsaXN0XG4gICAgICBsZXQgcGxpc3Q7XG4gICAgICB0cnkge1xuICAgICAgICBwbGlzdCA9IGJwbGlzdFBhcnNlLnBhcnNlQnVmZmVyKGJvZHkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2cuZXJyb3IoYEVycm9yIHBhcnNpbmcgYmluYXJ5IHBsaXN0OiAke2V9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYnBsaXN0UGFyc2UucGFyc2VCdWZmZXIgcmV0dXJucyBhbiBhcnJheVxuICAgICAgaWYgKHBsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBwbGlzdCA9IHBsaXN0WzBdO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBrZXkgb2YgWydXSVJNZXNzYWdlRGF0YUtleScsICdXSVJEZXN0aW5hdGlvbktleScsICdXSVJTb2NrZXREYXRhS2V5J10pIHtcbiAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBsaXN0W2tleV0pKSB7XG4gICAgICAgICAgcGxpc3Rba2V5XSA9IHBsaXN0W2tleV0udG9TdHJpbmcoXCJ1dGY4XCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwbGlzdC5fX3NlbGVjdG9yID09PSBcIl9ycGNfYXBwbGljYXRpb25TZW50RGF0YTpcIikge1xuICAgICAgICBsb2cuZGVidWcoJ1JlY2VpdmVkIGFwcGxpY2F0aW9uU2VudERhdGEgcmVzcG9uc2UnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhgUmVjZWl2aW5nIGRhdGEgZnJvbSByZW1vdGUgZGVidWdnZXI6ICcke3NpbXBsZVN0cmluZ2lmeShwbGlzdCl9J2ApO1xuICAgICAgfVxuXG4gICAgICAvLyBKdW1wIGZvcndhcmQgdGhlIGxlbmd0aCBvZiB0aGUgcGxpc3RcbiAgICAgIHRoaXMucmVhZFBvcyArPSBtc2dMZW5ndGg7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBob3cgbXVjaCBidWZmZXIgaXMgbGVmdFxuICAgICAgbGV0IGxlZnRPdmVyID0gdGhpcy5yZWNlaXZlZC5sZW5ndGggLSB0aGlzLnJlYWRQb3M7XG5cbiAgICAgIC8vIElzIHRoZXJlIHNvbWUgbGVmdCBvdmVyP1xuICAgICAgaWYgKGxlZnRPdmVyICE9PSAwKSB7XG4gICAgICAgIC8vIENvcHkgd2hhdCdzIGxlZnQgb3ZlciBpbnRvIGEgbmV3IGJ1ZmZlciwgYW5kIHNhdmUgaXQgZm9yIG5leHQgdGltZVxuICAgICAgICBsZXQgY2h1bmsgPSBuZXcgQnVmZmVyKGxlZnRPdmVyKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlZC5jb3B5KGNodW5rLCAwLCB0aGlzLnJlYWRQb3MpO1xuICAgICAgICB0aGlzLnJlY2VpdmVkID0gY2h1bms7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UsIGVtcHR5IHRoZSBidWZmZXIgYW5kIGdldCBvdXQgb2YgdGhlIGxvb3BcbiAgICAgICAgdGhpcy5yZWNlaXZlZCA9IG5ldyBCdWZmZXIoMCk7XG4gICAgICAgIGRhdGFMZWZ0T3ZlciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXNldCB0aGUgcmVhZCBwb3NpdGlvblxuICAgICAgdGhpcy5yZWFkUG9zID0gMDtcblxuICAgICAgLy8gTm93IGRvIHNvbWV0aGluZyB3aXRoIHRoZSBwbGlzdFxuICAgICAgaWYgKHBsaXN0KSB7XG4gICAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXIuaGFuZGxlTWVzc2FnZShwbGlzdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2V0VGltZWxpbmVFdmVudEhhbmRsZXIgKHRpbWVsaW5lRXZlbnRIYW5kbGVyKSB7XG4gICAgdGhpcy50aW1lbGluZUV2ZW50SGFuZGxlciA9IHRpbWVsaW5lRXZlbnRIYW5kbGVyO1xuICAgIHRoaXMubWVzc2FnZUhhbmRsZXIuc2V0VGltZWxpbmVFdmVudEhhbmRsZXIodGltZWxpbmVFdmVudEhhbmRsZXIpO1xuICB9XG59XG4iXX0=