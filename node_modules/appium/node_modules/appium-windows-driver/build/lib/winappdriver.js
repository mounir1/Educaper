'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _appiumBaseDriver = require('appium-base-driver');

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _teen_process = require('teen_process');

var _installer = require('./installer');

//import { retryInterval } from 'asyncbox';

var _child_process = require('child_process');

var _child_process2 = _interopRequireDefault(_child_process);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var REQD_PARAMS = ['app'];
var DEFAULT_HOST = '127.0.0.1';
var DEFAULT_PORT = "4823"; //  should be non-4723 to avoid conflict on the same box

var WinAppDriver = (function (_events$EventEmitter) {
  _inherits(WinAppDriver, _events$EventEmitter);

  function WinAppDriver() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, WinAppDriver);

    var host = opts.host;
    var port = opts.port;

    _get(Object.getPrototypeOf(WinAppDriver.prototype), 'constructor', this).call(this);

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _getIterator(REQD_PARAMS), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var req = _step.value;

        if (!opts || !opts[req]) {
          throw new Error('Option \'' + req + '\' is required!');
        }
        this[req] = opts[req];
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    this.proxyHost = host || DEFAULT_HOST;
    this.proxyPort = port || DEFAULT_PORT;
    this.proc = null;
    this.state = WinAppDriver.STATE_STOPPED;
    this.jwproxy = new _appiumBaseDriver.JWProxy({ server: this.proxyHost, port: this.proxyPort });
  }

  _createClass(WinAppDriver, [{
    key: 'start',
    value: function start() {
      var args, startDetector, processIsAlive, _arr, _loop, _i;

      return _regeneratorRuntime.async(function start$(context$2$0) {
        var _this = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap((0, _installer.verifyWAD)());

          case 2:
            if (context$2$0.sent) {
              context$2$0.next = 4;
              break;
            }

            throw new Error("Could not verify WinAppDriver install; re-run install");

          case 4:

            this.changeState(WinAppDriver.STATE_STARTING);

            // XXXYD TODO: would be better if WinAppDriver didn't require passing in /wd/hub as a param
            args = [this.proxyPort + "/wd/hub"];

            startDetector = function startDetector(stdout) {
              return stdout.indexOf("listening for requests") !== -1;
            };

            processIsAlive = false;
            context$2$0.prev = 8;
            context$2$0.next = 11;
            return _regeneratorRuntime.awrap(this.killAll());

          case 11:

            // set up our subprocess object
            this.proc = new _teen_process.SubProcess(_installer.WAD_INSTALL_PATH, args, {
              encoding: 'ucs2'
            });
            processIsAlive = true;

            // handle log output
            _arr = ['STDOUT', 'STDERR'];

            _loop = function () {
              var stream = _arr[_i];
              _this.proc.on('lines-' + stream.toLowerCase(), function (lines) {
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                  for (var _iterator2 = _getIterator(lines), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var l = _step2.value;

                    _logger2['default'].info('[' + stream + '] ' + l.trim());
                  }
                } catch (err) {
                  _didIteratorError2 = true;
                  _iteratorError2 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                      _iterator2['return']();
                    }
                  } finally {
                    if (_didIteratorError2) {
                      throw _iteratorError2;
                    }
                  }
                }
              });
            };

            for (_i = 0; _i < _arr.length; _i++) {
              _loop();
            }

            // handle out-of-bound exit by simply emitting a stopped state
            this.proc.on('exit', function (code, signal) {
              processIsAlive = false;
              if (_this.state !== WinAppDriver.STATE_STOPPED && _this.state !== WinAppDriver.STATE_STOPPING) {
                var msg = 'WinAppDriver exited unexpectedly with code ' + code + ', ' + ('signal ' + signal);
                _logger2['default'].error(msg);
                _this.changeState(WinAppDriver.STATE_STOPPED);
              }
            });
            _logger2['default'].info('Spawning winappdriver with: ' + this.winappdriver + ' ' + ('' + args.join(' ')));

            // start subproc and wait for startDetector
            context$2$0.next = 20;
            return _regeneratorRuntime.awrap(this.proc.start(startDetector));

          case 20:
            context$2$0.next = 22;
            return _regeneratorRuntime.awrap(this.waitForOnline());

          case 22:
            this.changeState(WinAppDriver.STATE_ONLINE);
            context$2$0.next = 32;
            break;

          case 25:
            context$2$0.prev = 25;
            context$2$0.t0 = context$2$0['catch'](8);

            this.emit(WinAppDriver.EVENT_ERROR, context$2$0.t0);
            // just because we had an error doesn't mean the winappdriver process
            // finished; we should clean up if necessary

            if (!processIsAlive) {
              context$2$0.next = 31;
              break;
            }

            context$2$0.next = 31;
            return _regeneratorRuntime.awrap(this.proc.stop());

          case 31:
            _logger2['default'].errorAndThrow(context$2$0.t0);

          case 32:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[8, 25]]);
    }
  }, {
    key: 'sessionId',
    value: function sessionId() {
      if (this.state !== WinAppDriver.STATE_ONLINE) {
        return null;
      }

      return this.jwproxy.sessionId;
    }
  }, {
    key: 'waitForOnline',
    value: function waitForOnline() {
      return _regeneratorRuntime.async(function waitForOnline$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            return context$2$0.abrupt('return', true);

          case 1:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'getStatus',

    // we need to make sure WAD hasn't crashed
    /*
    let winappdriverStopped = false;
    await retryInterval(20, 200, async () => {
      if (this.state === WinAppDriver.STATE_STOPPED) {
        // we are either stopped or stopping, so something went wrong
        winappdriverStopped = true;
        return;
      }
      await this.getStatus();
    });
    if (winappdriverStopped) {
      throw new Error('WinAppDriver crashed during startup.');
    }*/
    value: function getStatus() {
      return _regeneratorRuntime.async(function getStatus$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.jwproxy.command('/status', 'GET'));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'startSession',
    value: function startSession(caps) {
      return _regeneratorRuntime.async(function startSession$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            this.proxyReqRes = this.jwproxy.proxyReqRes.bind(this.jwproxy);
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap(this.jwproxy.command('/session', 'POST', { desiredCapabilities: caps }));

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'stop',
    value: function stop() {
      var emitStates = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
      return _regeneratorRuntime.async(function stop$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (emitStates) {
              this.changeState(WinAppDriver.STATE_STOPPING);
            }
            context$2$0.prev = 1;

            if (!this.proc) {
              context$2$0.next = 5;
              break;
            }

            context$2$0.next = 5;
            return _regeneratorRuntime.awrap(this.proc.stop());

          case 5:
            if (emitStates) {
              this.changeState(WinAppDriver.STATE_STOPPED);
            }
            context$2$0.next = 11;
            break;

          case 8:
            context$2$0.prev = 8;
            context$2$0.t0 = context$2$0['catch'](1);

            _logger2['default'].error(context$2$0.t0);

          case 11:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[1, 8]]);
    }
  }, {
    key: 'changeState',
    value: function changeState(state) {
      this.state = state;
      _logger2['default'].debug('WinAppDriver changed state to \'' + state + '\'');
      this.emit(WinAppDriver.EVENT_CHANGED, { state: state });
    }
  }, {
    key: 'sendCommand',
    value: function sendCommand(url, method, body) {
      return _regeneratorRuntime.async(function sendCommand$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.jwproxy.command(url, method, body));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'proxyReq',
    value: function proxyReq(req, res) {
      return _regeneratorRuntime.async(function proxyReq$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.jwproxy.proxyReqRes(req, res));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'killAll',
    value: function killAll() {
      var cmd;
      return _regeneratorRuntime.async(function killAll$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            cmd = undefined;

            // js hint cannot handle backticks, even escaped, within template literals
            cmd = "FOR /F \"usebackq tokens=5\" %a in (`netstat -nao ^| " + "findstr /R /C:\"" + this.proxyPort + " \"`) do (" + "FOR /F \"usebackq\" %b in (`TASKLIST /FI \"PID eq %a\" ^| " + "findstr /I winappdriver.exe`) do (IF NOT %b==\"\" TASKKILL " + "/F /PID %a))";
            _logger2['default'].info('Killing any old WinAppDrivers, running: ' + cmd);
            context$2$0.prev = 3;
            context$2$0.next = 6;
            return _regeneratorRuntime.awrap(_bluebird2['default'].promisify(_child_process2['default'].exec)(cmd));

          case 6:
            _logger2['default'].info("Successfully cleaned up old WinAppDrivers");
            context$2$0.next = 12;
            break;

          case 9:
            context$2$0.prev = 9;
            context$2$0.t0 = context$2$0['catch'](3);

            _logger2['default'].info("No old WinAppDrivers seemed to exist");

          case 12:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[3, 9]]);
    }
  }, {
    key: 'deleteSession',
    value: function deleteSession() {
      return _regeneratorRuntime.async(function deleteSession$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            _logger2['default'].debug('Deleting WinAppDriver server session');
            // rely on jwproxy's intelligence to know what we're talking about and
            // delete the current session
            context$2$0.prev = 1;
            context$2$0.next = 4;
            return _regeneratorRuntime.awrap(this.jwproxy.command('/', 'DELETE'));

          case 4:
            context$2$0.next = 9;
            break;

          case 6:
            context$2$0.prev = 6;
            context$2$0.t0 = context$2$0['catch'](1);

            _logger2['default'].warn('Did not get confirmation WinAppDriver deleteSession worked; ' + ('Error was: ' + context$2$0.t0));

          case 9:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[1, 6]]);
    }
  }]);

  return WinAppDriver;
})(_events2['default'].EventEmitter);

WinAppDriver.EVENT_ERROR = 'winappdriver_error';
WinAppDriver.EVENT_CHANGED = 'stateChanged';
WinAppDriver.STATE_STOPPED = 'stopped';
WinAppDriver.STATE_STARTING = 'starting';
WinAppDriver.STATE_ONLINE = 'online';
WinAppDriver.STATE_STOPPING = 'stopping';

exports['default'] = WinAppDriver;
module.exports = exports['default'];

// XXXYD TODO: bring this back once WinAppDriver supports status correctly

// TODO WAD doesn't support the status command correctly, so just return
// true for now

// use cp.exec instead of teen process because of crazy windows quoting
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi93aW5hcHBkcml2ZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0JBQW1CLFFBQVE7Ozs7Z0NBQ0gsb0JBQW9COztzQkFDNUIsVUFBVTs7Ozs0QkFDQyxjQUFjOzt5QkFDRyxhQUFhOzs7OzZCQUUxQyxlQUFlOzs7O3dCQUNoQixVQUFVOzs7O0FBRXhCLElBQU0sV0FBVyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDNUIsSUFBTSxZQUFZLEdBQUcsV0FBVyxDQUFDO0FBQ2pDLElBQU0sWUFBWSxHQUFHLE1BQU0sQ0FBQzs7SUFFdEIsWUFBWTtZQUFaLFlBQVk7O0FBQ0osV0FEUixZQUFZLEdBQ1E7UUFBWCxJQUFJLHlEQUFHLEVBQUU7OzBCQURsQixZQUFZOztRQUVQLElBQUksR0FBVSxJQUFJLENBQWxCLElBQUk7UUFBRSxJQUFJLEdBQUksSUFBSSxDQUFaLElBQUk7O0FBQ2pCLCtCQUhFLFlBQVksNkNBR047Ozs7Ozs7QUFFUix3Q0FBZ0IsV0FBVyw0R0FBRTtZQUFwQixHQUFHOztBQUNWLFlBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7QUFDdkIsZ0JBQU0sSUFBSSxLQUFLLGVBQVksR0FBRyxxQkFBaUIsQ0FBQztTQUNqRDtBQUNELFlBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7T0FDdkI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFRCxRQUFJLENBQUMsU0FBUyxHQUFHLElBQUksSUFBSSxZQUFZLENBQUM7QUFDdEMsUUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLElBQUksWUFBWSxDQUFDO0FBQ3RDLFFBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBQ2pCLFFBQUksQ0FBQyxLQUFLLEdBQUcsWUFBWSxDQUFDLGFBQWEsQ0FBQztBQUN4QyxRQUFJLENBQUMsT0FBTyxHQUFHLDhCQUFZLEVBQUMsTUFBTSxFQUFFLElB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IGV2ZW50cyBmcm9tICdldmVudHMnO1xuaW1wb3J0IHsgSldQcm94eSB9IGZyb20gJ2FwcGl1bS1iYXNlLWRyaXZlcic7XG5pbXBvcnQgbG9nIGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCB7IFN1YlByb2Nlc3MgfSBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuaW1wb3J0IHsgV0FEX0lOU1RBTExfUEFUSCwgdmVyaWZ5V0FEIH0gZnJvbSAnLi9pbnN0YWxsZXInO1xuLy9pbXBvcnQgeyByZXRyeUludGVydmFsIH0gZnJvbSAnYXN5bmNib3gnO1xuaW1wb3J0IGNwIGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IEIgZnJvbSAnYmx1ZWJpcmQnO1xuXG5jb25zdCBSRVFEX1BBUkFNUyA9IFsnYXBwJ107XG5jb25zdCBERUZBVUxUX0hPU1QgPSAnMTI3LjAuMC4xJztcbmNvbnN0IERFRkFVTFRfUE9SVCA9IFwiNDgyM1wiOyAvLyAgc2hvdWxkIGJlIG5vbi00NzIzIHRvIGF2b2lkIGNvbmZsaWN0IG9uIHRoZSBzYW1lIGJveFxuXG5jbGFzcyBXaW5BcHBEcml2ZXIgZXh0ZW5kcyBldmVudHMuRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IgKG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHtob3N0LCBwb3J0fSA9IG9wdHM7XG4gICAgc3VwZXIoKTtcblxuICAgIGZvciAobGV0IHJlcSBvZiBSRVFEX1BBUkFNUykge1xuICAgICAgaWYgKCFvcHRzIHx8ICFvcHRzW3JlcV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPcHRpb24gJyR7cmVxfScgaXMgcmVxdWlyZWQhYCk7XG4gICAgICB9XG4gICAgICB0aGlzW3JlcV0gPSBvcHRzW3JlcV07XG4gICAgfVxuXG4gICAgdGhpcy5wcm94eUhvc3QgPSBob3N0IHx8IERFRkFVTFRfSE9TVDtcbiAgICB0aGlzLnByb3h5UG9ydCA9IHBvcnQgfHwgREVGQVVMVF9QT1JUO1xuICAgIHRoaXMucHJvYyA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IFdpbkFwcERyaXZlci5TVEFURV9TVE9QUEVEO1xuICAgIHRoaXMuandwcm94eSA9IG5ldyBKV1Byb3h5KHtzZXJ2ZXI6IHRoaXMucHJveHlIb3N0LCBwb3J0OiB0aGlzLnByb3h5UG9ydH0pO1xuICB9XG5cbiAgYXN5bmMgc3RhcnQgKCkge1xuICAgIGlmICghYXdhaXQgdmVyaWZ5V0FEKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCB2ZXJpZnkgV2luQXBwRHJpdmVyIGluc3RhbGw7IHJlLXJ1biBpbnN0YWxsXCIpO1xuICAgIH1cbiAgICAgICAgXG4gICAgdGhpcy5jaGFuZ2VTdGF0ZShXaW5BcHBEcml2ZXIuU1RBVEVfU1RBUlRJTkcpO1xuICAgIFxuICAgIC8vIFhYWFlEIFRPRE86IHdvdWxkIGJlIGJldHRlciBpZiBXaW5BcHBEcml2ZXIgZGlkbid0IHJlcXVpcmUgcGFzc2luZyBpbiAvd2QvaHViIGFzIGEgcGFyYW1cbiAgICBsZXQgYXJncyA9IFt0aGlzLnByb3h5UG9ydCArIFwiL3dkL2h1YlwiXTtcblxuICAgIGNvbnN0IHN0YXJ0RGV0ZWN0b3IgPSAoc3Rkb3V0KSA9PiB7XG4gICAgICByZXR1cm4gc3Rkb3V0LmluZGV4T2YoXCJsaXN0ZW5pbmcgZm9yIHJlcXVlc3RzXCIpICE9PSAtMTsgICAgICAgIFxuICAgIH07XG5cbiAgICBsZXQgcHJvY2Vzc0lzQWxpdmUgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5raWxsQWxsKCk7XG5cbiAgICAgIC8vIHNldCB1cCBvdXIgc3VicHJvY2VzcyBvYmplY3RcbiAgICAgIHRoaXMucHJvYyA9IG5ldyBTdWJQcm9jZXNzKFdBRF9JTlNUQUxMX1BBVEgsIGFyZ3MsIHtcbiAgICAgICAgZW5jb2Rpbmc6ICd1Y3MyJ1xuICAgICAgfSk7XG4gICAgICBwcm9jZXNzSXNBbGl2ZSA9IHRydWU7XG5cbiAgICAgIC8vIGhhbmRsZSBsb2cgb3V0cHV0XG4gICAgICBmb3IgKGxldCBzdHJlYW0gb2YgWydTVERPVVQnLCAnU1RERVJSJ10pIHtcbiAgICAgICAgdGhpcy5wcm9jLm9uKGBsaW5lcy0ke3N0cmVhbS50b0xvd2VyQ2FzZSgpfWAsIChsaW5lcykgPT4ge1xuICAgICAgICAgIGZvciAobGV0IGwgb2YgbGluZXMpIHtcbiAgICAgICAgICAgIGxvZy5pbmZvKGBbJHtzdHJlYW19XSAke2wudHJpbSgpfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZSBvdXQtb2YtYm91bmQgZXhpdCBieSBzaW1wbHkgZW1pdHRpbmcgYSBzdG9wcGVkIHN0YXRlXG4gICAgICB0aGlzLnByb2Mub24oJ2V4aXQnLCAoY29kZSwgc2lnbmFsKSA9PiB7XG4gICAgICAgIHByb2Nlc3NJc0FsaXZlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBXaW5BcHBEcml2ZXIuU1RBVEVfU1RPUFBFRCAmJlxuICAgICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gV2luQXBwRHJpdmVyLlNUQVRFX1NUT1BQSU5HKSB7XG4gICAgICAgICAgbGV0IG1zZyA9IGBXaW5BcHBEcml2ZXIgZXhpdGVkIHVuZXhwZWN0ZWRseSB3aXRoIGNvZGUgJHtjb2RlfSwgYCArXG4gICAgICAgICAgICAgICAgICAgIGBzaWduYWwgJHtzaWduYWx9YDtcbiAgICAgICAgICBsb2cuZXJyb3IobXNnKTtcbiAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFdpbkFwcERyaXZlci5TVEFURV9TVE9QUEVEKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBsb2cuaW5mbyhgU3Bhd25pbmcgd2luYXBwZHJpdmVyIHdpdGg6ICR7dGhpcy53aW5hcHBkcml2ZXJ9IGAgK1xuICAgICAgICAgICAgICAgYCR7YXJncy5qb2luKCcgJyl9YCk7XG5cbiAgICAgIC8vIHN0YXJ0IHN1YnByb2MgYW5kIHdhaXQgZm9yIHN0YXJ0RGV0ZWN0b3JcbiAgICAgIGF3YWl0IHRoaXMucHJvYy5zdGFydChzdGFydERldGVjdG9yKTtcblxuICAgICAgLy8gWFhYWUQgVE9ETzogYnJpbmcgdGhpcyBiYWNrIG9uY2UgV2luQXBwRHJpdmVyIHN1cHBvcnRzIHN0YXR1cyBjb3JyZWN0bHlcbiAgICAgIGF3YWl0IHRoaXMud2FpdEZvck9ubGluZSgpO1xuICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShXaW5BcHBEcml2ZXIuU1RBVEVfT05MSU5FKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmVtaXQoV2luQXBwRHJpdmVyLkVWRU5UX0VSUk9SLCBlKTtcbiAgICAgIC8vIGp1c3QgYmVjYXVzZSB3ZSBoYWQgYW4gZXJyb3IgZG9lc24ndCBtZWFuIHRoZSB3aW5hcHBkcml2ZXIgcHJvY2Vzc1xuICAgICAgLy8gZmluaXNoZWQ7IHdlIHNob3VsZCBjbGVhbiB1cCBpZiBuZWNlc3NhcnlcbiAgICAgIGlmIChwcm9jZXNzSXNBbGl2ZSkge1xuICAgICAgICBhd2FpdCB0aGlzLnByb2Muc3RvcCgpO1xuICAgICAgfVxuICAgICAgbG9nLmVycm9yQW5kVGhyb3coZSk7XG4gICAgfVxuICB9ICAgICAgXG5cbiAgc2Vzc2lvbklkICgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gV2luQXBwRHJpdmVyLlNUQVRFX09OTElORSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuandwcm94eS5zZXNzaW9uSWQ7XG4gIH1cblxuICBhc3luYyB3YWl0Rm9yT25saW5lICgpIHtcbiAgICAvLyBUT0RPIFdBRCBkb2Vzbid0IHN1cHBvcnQgdGhlIHN0YXR1cyBjb21tYW5kIGNvcnJlY3RseSwgc28ganVzdCByZXR1cm5cbiAgICAvLyB0cnVlIGZvciBub3dcbiAgICByZXR1cm4gdHJ1ZTtcblxuICAgIC8vIHdlIG5lZWQgdG8gbWFrZSBzdXJlIFdBRCBoYXNuJ3QgY3Jhc2hlZFxuICAgIC8qXG4gICAgbGV0IHdpbmFwcGRyaXZlclN0b3BwZWQgPSBmYWxzZTtcbiAgICBhd2FpdCByZXRyeUludGVydmFsKDIwLCAyMDAsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBXaW5BcHBEcml2ZXIuU1RBVEVfU1RPUFBFRCkge1xuICAgICAgICAvLyB3ZSBhcmUgZWl0aGVyIHN0b3BwZWQgb3Igc3RvcHBpbmcsIHNvIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICAgIHdpbmFwcGRyaXZlclN0b3BwZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLmdldFN0YXR1cygpO1xuICAgIH0pO1xuICAgIGlmICh3aW5hcHBkcml2ZXJTdG9wcGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpbkFwcERyaXZlciBjcmFzaGVkIGR1cmluZyBzdGFydHVwLicpO1xuICAgIH0qL1xuICB9XG5cbiAgYXN5bmMgZ2V0U3RhdHVzICgpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5qd3Byb3h5LmNvbW1hbmQoJy9zdGF0dXMnLCAnR0VUJyk7XG4gIH1cblxuICBhc3luYyBzdGFydFNlc3Npb24gKGNhcHMpIHtcbiAgICB0aGlzLnByb3h5UmVxUmVzID0gdGhpcy5qd3Byb3h5LnByb3h5UmVxUmVzLmJpbmQodGhpcy5qd3Byb3h5KTtcbiAgICBhd2FpdCB0aGlzLmp3cHJveHkuY29tbWFuZCgnL3Nlc3Npb24nLCAnUE9TVCcsIHtkZXNpcmVkQ2FwYWJpbGl0aWVzOiBjYXBzfSk7XG4gIH1cblxuICBhc3luYyBzdG9wIChlbWl0U3RhdGVzID0gdHJ1ZSkge1xuICAgIGlmIChlbWl0U3RhdGVzKSB7XG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKFdpbkFwcERyaXZlci5TVEFURV9TVE9QUElORyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5wcm9jKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucHJvYy5zdG9wKCk7XG4gICAgICB9XG4gICAgICBpZiAoZW1pdFN0YXRlcykge1xuICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFdpbkFwcERyaXZlci5TVEFURV9TVE9QUEVEKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2cuZXJyb3IoZSk7XG4gICAgfVxuICB9XG5cbiAgY2hhbmdlU3RhdGUgKHN0YXRlKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIGxvZy5kZWJ1ZyhgV2luQXBwRHJpdmVyIGNoYW5nZWQgc3RhdGUgdG8gJyR7c3RhdGV9J2ApO1xuICAgIHRoaXMuZW1pdChXaW5BcHBEcml2ZXIuRVZFTlRfQ0hBTkdFRCwge3N0YXRlfSk7XG4gIH1cblxuICBhc3luYyBzZW5kQ29tbWFuZCAodXJsLCBtZXRob2QsIGJvZHkpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5qd3Byb3h5LmNvbW1hbmQodXJsLCBtZXRob2QsIGJvZHkpO1xuICB9XG5cbiAgYXN5bmMgcHJveHlSZXEgKHJlcSwgcmVzKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuandwcm94eS5wcm94eVJlcVJlcyhyZXEsIHJlcyk7XG4gIH1cblxuICBhc3luYyBraWxsQWxsICgpIHtcbiAgICBsZXQgY21kO1xuICAgIC8vIGpzIGhpbnQgY2Fubm90IGhhbmRsZSBiYWNrdGlja3MsIGV2ZW4gZXNjYXBlZCwgd2l0aGluIHRlbXBsYXRlIGxpdGVyYWxzXG4gICAgY21kID0gXCJGT1IgL0YgXFxcInVzZWJhY2txIHRva2Vucz01XFxcIiAlYSBpbiAoYG5ldHN0YXQgLW5hbyBefCBcIiArXG4gICAgICAgICAgXCJmaW5kc3RyIC9SIC9DOlxcXCJcIiArIHRoaXMucHJveHlQb3J0ICsgXCIgXFxcImApIGRvIChcIiArXG4gICAgICAgICAgXCJGT1IgL0YgXFxcInVzZWJhY2txXFxcIiAlYiBpbiAoYFRBU0tMSVNUIC9GSSBcXFwiUElEIGVxICVhXFxcIiBefCBcIiArXG4gICAgICAgICAgXCJmaW5kc3RyIC9JIHdpbmFwcGRyaXZlci5leGVgKSBkbyAoSUYgTk9UICViPT1cXFwiXFxcIiBUQVNLS0lMTCBcIiArXG4gICAgICAgICAgXCIvRiAvUElEICVhKSlcIjtcbiAgICBsb2cuaW5mbyhgS2lsbGluZyBhbnkgb2xkIFdpbkFwcERyaXZlcnMsIHJ1bm5pbmc6ICR7Y21kfWApO1xuICAgIHRyeSB7XG4gICAgICAvLyB1c2UgY3AuZXhlYyBpbnN0ZWFkIG9mIHRlZW4gcHJvY2VzcyBiZWNhdXNlIG9mIGNyYXp5IHdpbmRvd3MgcXVvdGluZ1xuICAgICAgYXdhaXQgKEIucHJvbWlzaWZ5KGNwLmV4ZWMpKShjbWQpO1xuICAgICAgbG9nLmluZm8oXCJTdWNjZXNzZnVsbHkgY2xlYW5lZCB1cCBvbGQgV2luQXBwRHJpdmVyc1wiKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy5pbmZvKFwiTm8gb2xkIFdpbkFwcERyaXZlcnMgc2VlbWVkIHRvIGV4aXN0XCIpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGRlbGV0ZVNlc3Npb24gKCkge1xuICAgIGxvZy5kZWJ1ZygnRGVsZXRpbmcgV2luQXBwRHJpdmVyIHNlcnZlciBzZXNzaW9uJyk7XG4gICAgLy8gcmVseSBvbiBqd3Byb3h5J3MgaW50ZWxsaWdlbmNlIHRvIGtub3cgd2hhdCB3ZSdyZSB0YWxraW5nIGFib3V0IGFuZFxuICAgIC8vIGRlbGV0ZSB0aGUgY3VycmVudCBzZXNzaW9uXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuandwcm94eS5jb21tYW5kKCcvJywgJ0RFTEVURScpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLndhcm4oYERpZCBub3QgZ2V0IGNvbmZpcm1hdGlvbiBXaW5BcHBEcml2ZXIgZGVsZXRlU2Vzc2lvbiB3b3JrZWQ7IGAgK1xuICAgICAgICBgRXJyb3Igd2FzOiAke2Vycn1gKTtcbiAgICB9XG4gIH1cbn1cblxuV2luQXBwRHJpdmVyLkVWRU5UX0VSUk9SID0gJ3dpbmFwcGRyaXZlcl9lcnJvcic7XG5XaW5BcHBEcml2ZXIuRVZFTlRfQ0hBTkdFRCA9ICdzdGF0ZUNoYW5nZWQnO1xuV2luQXBwRHJpdmVyLlNUQVRFX1NUT1BQRUQgPSAnc3RvcHBlZCc7XG5XaW5BcHBEcml2ZXIuU1RBVEVfU1RBUlRJTkcgPSAnc3RhcnRpbmcnO1xuV2luQXBwRHJpdmVyLlNUQVRFX09OTElORSA9ICdvbmxpbmUnO1xuV2luQXBwRHJpdmVyLlNUQVRFX1NUT1BQSU5HID0gJ3N0b3BwaW5nJztcblxuZXhwb3J0IGRlZmF1bHQgV2luQXBwRHJpdmVyO1xuIl0sInNvdXJjZVJvb3QiOiIuLi8uLiJ9
