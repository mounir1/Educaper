'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _teen_process = require('teen_process');

var _asyncbox = require('asyncbox');

var _appiumXcode = require('appium-xcode');

var _nodeSimctl = require('node-simctl');

var _appiumSupport = require('appium-support');

var _certificate = require('./certificate');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _simulatorXcode6 = require('./simulator-xcode-6');

var _simulatorXcode62 = _interopRequireDefault(_simulatorXcode6);

var OSASCRIPT_TIMEOUT = 10000;

function killAllSimulators() {
  var timeout = arguments.length <= 0 || arguments[0] === undefined ? OSASCRIPT_TIMEOUT : arguments[0];

  var appName, xcodeVersion, errString, remainingDevices, allSimsAreDown, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, device;

  return _regeneratorRuntime.async(function killAllSimulators$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        allSimsAreDown = function allSimsAreDown() {
          var devices;
          return _regeneratorRuntime.async(function allSimsAreDown$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                remainingDevices = [];
                context$2$0.next = 3;
                return _regeneratorRuntime.awrap((0, _nodeSimctl.getDevices)());

              case 3:
                devices = context$2$0.sent;

                devices = _lodash2['default'].flatten(_lodash2['default'].values(devices));
                return context$2$0.abrupt('return', _lodash2['default'].every(devices, function (sim) {
                  var state = sim.state.toLowerCase();
                  var done = state === 'shutdown' || state === 'unavailable' || state === 'disconnected';
                  if (!done) {
                    remainingDevices.push('Simulator not shut down: ' + sim.name + ' (' + sim.sdk + ', udid: ' + (sim.udid + ') is still in state \'' + state + '\''));
                  }
                  return done;
                }));

              case 6:
              case 'end':
                return context$2$0.stop();
            }
          }, null, this);
        };

        _logger2['default'].debug('Killing all iOS Simulators');

        appName = undefined;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap((0, _appiumXcode.getVersion)(true));

      case 5:
        xcodeVersion = context$1$0.sent;

        if (xcodeVersion.major >= 7) {
          appName = 'Simulator';
        } else {
          appName = 'iOS Simulator';
        }

        context$1$0.prev = 7;
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('osascript', ['-e', 'quit app "' + appName + '"'], { timeout: timeout }));

      case 10:
        context$1$0.next = 26;
        break;

      case 12:
        context$1$0.prev = 12;
        context$1$0.t0 = context$1$0['catch'](7);
        errString = JSON.stringify(context$1$0.t0);

        if (!errString.match(/Application isn.t running/)) {
          context$1$0.next = 19;
          break;
        }

        // on some systems we get an error that the application is not running
        _logger2['default'].debug('Application is not running. Continuing');
        context$1$0.next = 26;
        break;

      case 19:
        if (!context$1$0.t0.message.match(/timed out/)) {
          context$1$0.next = 25;
          break;
        }

        // sometimes, especially in xcode 8, the sim hangs
        _logger2['default'].debug('Killing simulator timed out. Using killall signal');
        context$1$0.next = 23;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('killall', [appName]));

      case 23:
        context$1$0.next = 26;
        break;

      case 25:
        _logger2['default'].errorAndThrow(context$1$0.t0);

      case 26:
        remainingDevices = undefined;
        context$1$0.prev = 27;
        context$1$0.next = 30;
        return _regeneratorRuntime.awrap((0, _asyncbox.waitForCondition)(allSimsAreDown, {
          waitMs: 60 * 1000,
          intervalMs: 200
        }));

      case 30:
        context$1$0.next = 56;
        break;

      case 32:
        context$1$0.prev = 32;
        context$1$0.t1 = context$1$0['catch'](27);

        if (!(remainingDevices && remainingDevices.length !== 0)) {
          context$1$0.next = 55;
          break;
        }

        _logger2['default'].error('The following devices are not in the correct state:');
        _iteratorNormalCompletion = true;
        _didIteratorError = false;
        _iteratorError = undefined;
        context$1$0.prev = 39;
        for (_iterator = _getIterator(remainingDevices); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          device = _step.value;

          _logger2['default'].error('    ' + device);
        }
        context$1$0.next = 47;
        break;

      case 43:
        context$1$0.prev = 43;
        context$1$0.t2 = context$1$0['catch'](39);
        _didIteratorError = true;
        _iteratorError = context$1$0.t2;

      case 47:
        context$1$0.prev = 47;
        context$1$0.prev = 48;

        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }

      case 50:
        context$1$0.prev = 50;

        if (!_didIteratorError) {
          context$1$0.next = 53;
          break;
        }

        throw _iteratorError;

      case 53:
        return context$1$0.finish(50);

      case 54:
        return context$1$0.finish(47);

      case 55:
        throw context$1$0.t1;

      case 56:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[7, 12], [27, 32], [39, 43, 47, 55], [48,, 50, 54]]);
}

function endAllSimulatorDaemons() {
  var _arr, _i, servicePattern, launchCtlCommand, stopCmd, removeCmd;

  return _regeneratorRuntime.async(function endAllSimulatorDaemons$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _logger2['default'].debug('Ending all simulator daemons');
        _arr = ['com.apple.iphonesimulator', 'com.apple.CoreSimulator'];
        _i = 0;

      case 3:
        if (!(_i < _arr.length)) {
          context$1$0.next = 28;
          break;
        }

        servicePattern = _arr[_i];

        _logger2['default'].debug('Killing any other ' + servicePattern + ' daemons');
        launchCtlCommand = 'launchctl list | grep ' + servicePattern + ' | cut -f 3 | xargs -n 1 launchctl';
        context$1$0.prev = 7;
        stopCmd = launchCtlCommand + ' stop';
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('bash', ['-c', stopCmd]));

      case 11:
        context$1$0.next = 16;
        break;

      case 13:
        context$1$0.prev = 13;
        context$1$0.t0 = context$1$0['catch'](7);

        _logger2['default'].warn('Could not stop ' + servicePattern + ' daemons, carrying on anyway!');

      case 16:
        context$1$0.prev = 16;
        removeCmd = launchCtlCommand + ' remove';
        context$1$0.next = 20;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('bash', ['-c', removeCmd]));

      case 20:
        context$1$0.next = 25;
        break;

      case 22:
        context$1$0.prev = 22;
        context$1$0.t1 = context$1$0['catch'](16);

        _logger2['default'].warn('Could not remove ' + servicePattern + ' daemons, carrying on anyway!');

      case 25:
        _i++;
        context$1$0.next = 3;
        break;

      case 28:
        context$1$0.prev = 28;
        context$1$0.next = 31;
        return _regeneratorRuntime.awrap((0, _asyncbox.waitForCondition)(function callee$1$0() {
          var _ref, stdout;

          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap((0, _teen_process.exec)('bash', ['-c', 'ps -e  | grep launchd_sim | grep -v bash | grep -v grep | awk {\'print$1\'}']));

              case 2:
                _ref = context$2$0.sent;
                stdout = _ref.stdout;
                return context$2$0.abrupt('return', stdout.trim().length === 0);

              case 5:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this);
        }, { waitMs: 5000, intervalMs: 500 }));

      case 31:
        context$1$0.next = 36;
        break;

      case 33:
        context$1$0.prev = 33;
        context$1$0.t2 = context$1$0['catch'](28);

        _logger2['default'].warn('Could not end all simulator daemons, carrying on!');

      case 36:
        _logger2['default'].debug('Finishing ending all simulator daemons');

      case 37:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[7, 13], [16, 22], [28, 33]]);
}

function simExists(udid) {
  var devices;
  return _regeneratorRuntime.async(function simExists$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap((0, _nodeSimctl.getDevices)());

      case 2:
        devices = context$1$0.sent;

        devices = _lodash2['default'].toPairs(devices).map(function (pair) {
          return pair[1];
        }).reduce(function (a, b) {
          return a.concat(b);
        }, []);
        return context$1$0.abrupt('return', !!_lodash2['default'].find(devices, function (sim) {
          return sim.udid === udid;
        }));

      case 5:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function safeRimRaf(delPath) {
  var tryNum = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
  return _regeneratorRuntime.async(function safeRimRaf$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(delPath));

      case 3:
        context$1$0.next = 16;
        break;

      case 5:
        context$1$0.prev = 5;
        context$1$0.t0 = context$1$0['catch'](0);

        if (!(tryNum < 20)) {
          context$1$0.next = 16;
          break;
        }

        if (!(context$1$0.t0.message.indexOf('ENOTEMPTY') !== -1)) {
          context$1$0.next = 13;
          break;
        }

        _logger2['default'].debug('Path \'' + delPath + '\' was not empty during delete; retrying');
        return context$1$0.abrupt('return', safeRimRaf(delPath, tryNum + 1));

      case 13:
        if (!(context$1$0.t0.message.indexOf('ENOENT') !== -1)) {
          context$1$0.next = 16;
          break;
        }

        _logger2['default'].debug('Path \'' + delPath + '\'\' did not exist when we tried to delete, ignoring');
        return context$1$0.abrupt('return', safeRimRaf(delPath, tryNum + 1));

      case 16:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 5]]);
}

function installSSLCert(pemText, udid) {
  var tempFileName, pathToKeychain, certificate;
  return _regeneratorRuntime.async(function installSSLCert$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        tempFileName = _path2['default'].resolve(__dirname + '/temp-ssl-cert.pem');
        pathToKeychain = _path2['default'].resolve(new _simulatorXcode62['default'](udid).getDir());
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(tempFileName, pemText));

      case 4:
        certificate = new _certificate.Certificate(tempFileName);
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(certificate.add(pathToKeychain));

      case 7:
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.unlink(tempFileName));

      case 9:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function uninstallSSLCert(pemText, udid) {
  var tempFileName, pathToKeychain, certificate;
  return _regeneratorRuntime.async(function uninstallSSLCert$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        tempFileName = _path2['default'].resolve(__dirname + '/temp-ssl-cert.pem');
        pathToKeychain = _path2['default'].resolve(new _simulatorXcode62['default'](udid).getDir());
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(tempFileName, pemText));

      case 4:
        certificate = new _certificate.Certificate(tempFileName);
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(certificate.remove(pathToKeychain));

      case 7:
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.unlink(tempFileName));

      case 9:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

exports.killAllSimulators = killAllSimulators;
exports.endAllSimulatorDaemons = endAllSimulatorDaemons;
exports.safeRimRaf = safeRimRaf;
exports.simExists = simExists;
exports.installSSLCert = installSSLCert;
exports.uninstallSSLCert = uninstallSSLCert;

// wait for all the devices to be shutdown before Continuing
// but only print out the failed ones when they are actually fully failed

// waiting until the simulator service has died.

// see the README for github.com/appium/node-simctl for example output of getDevices()
//# sourceMappingURL=data:application/json;charset=utf8;base64,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LEdBQUcsa0JBQUssT0FBTyxDQUFDLGlDQUFjLElBQUksQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDOzt5Q0FDekQsa0JBQUcsU0FBUyxDQUFDLFlBQVksRUFBRSxPQUFPLENBQUM7OztBQUNyQyxtQkFBVyxHQUFHLDZCQUFnQixZQUFZLENBQUM7O3lDQUN6QyxXQUFXLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQzs7Ozt5Q0FDeEIsa0JBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQzs7Ozs7Ozs7OztDQUNyQzs7QUFFRCxTQUFlLGdCQUFnQixDQUFFLE9BQU8sRUFBRSxJQUFJO01BQ3hDLFlBQVksRUFDWixjQUFjLEVBRWQsV0FBVzs7OztBQUhYLG9CQUFZLEdBQUcsa0JBQUssT0FBTyxDQUFJLFNBQVMsd0JBQXFCO0FBQzdELHNCQUFjLEdBQUcsa0JBQUssT0FBTyxDQUFDLGlDQUFjLElBQUksQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDOzt5Q0FDekQsa0JBQUcsU0FBUyxDQUFDLFlBQVksRUFBRSxPQUFPLENBQUM7OztBQUNyQyxtQkFBVyxHQUFHLDZCQUFnQixZQUFZLENBQUM7O3lDQUN6QyxXQUFXLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQzs7Ozt5Q0FDM0Isa0JBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQzs7Ozs7Ozs7OztDQUNyQzs7UUFFUSxpQkFBaUIsR0FBakIsaUJBQWlCO1FBQUUsc0JBQXNCLEdBQXRCLHNCQUFzQjtRQUFFLFVBQVUsR0FBVixVQUFVO1FBQUUsU0FBUyxHQUFULFNBQVM7UUFBRSxjQUFjLEdBQWQsY0FBYztRQUFFLGdCQUFnQixHQUFoQixnQkFBZ0IiLCJmaWxlIjoibGliL3V0aWxzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGxvZyBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgZXhlYyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5pbXBvcnQgeyB3YWl0Rm9yQ29uZGl0aW9uIH0gZnJvbSAnYXN5bmNib3gnO1xuaW1wb3J0IHsgZ2V0VmVyc2lvbiB9IGZyb20gJ2FwcGl1bS14Y29kZSc7XG5pbXBvcnQgeyBnZXREZXZpY2VzIH0gZnJvbSAnbm9kZS1zaW1jdGwnO1xuaW1wb3J0IHsgZnMgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgeyBDZXJ0aWZpY2F0ZSB9IGZyb20gJy4vY2VydGlmaWNhdGUnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgU2ltdWxhdG9yIGZyb20gJy4vc2ltdWxhdG9yLXhjb2RlLTYnO1xuXG5jb25zdCBPU0FTQ1JJUFRfVElNRU9VVCA9IDEwMDAwO1xuXG5hc3luYyBmdW5jdGlvbiBraWxsQWxsU2ltdWxhdG9ycyAodGltZW91dCA9IE9TQVNDUklQVF9USU1FT1VUKSB7XG4gIGxvZy5kZWJ1ZygnS2lsbGluZyBhbGwgaU9TIFNpbXVsYXRvcnMnKTtcblxuICBsZXQgYXBwTmFtZTtcbiAgbGV0IHhjb2RlVmVyc2lvbiA9IGF3YWl0IGdldFZlcnNpb24odHJ1ZSk7XG4gIGlmICh4Y29kZVZlcnNpb24ubWFqb3IgPj0gNykge1xuICAgIGFwcE5hbWUgPSAnU2ltdWxhdG9yJztcbiAgfSBlbHNlIHtcbiAgICBhcHBOYW1lID0gJ2lPUyBTaW11bGF0b3InO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBhd2FpdCBleGVjKCdvc2FzY3JpcHQnLCBbJy1lJywgYHF1aXQgYXBwIFwiJHthcHBOYW1lfVwiYF0sIHt0aW1lb3V0fSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsZXQgZXJyU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZSk7XG4gICAgaWYgKGVyclN0cmluZy5tYXRjaCgvQXBwbGljYXRpb24gaXNuLnQgcnVubmluZy8pKSB7XG4gICAgICAvLyBvbiBzb21lIHN5c3RlbXMgd2UgZ2V0IGFuIGVycm9yIHRoYXQgdGhlIGFwcGxpY2F0aW9uIGlzIG5vdCBydW5uaW5nXG4gICAgICBsb2cuZGVidWcoJ0FwcGxpY2F0aW9uIGlzIG5vdCBydW5uaW5nLiBDb250aW51aW5nJyk7XG4gICAgfSBlbHNlIGlmIChlLm1lc3NhZ2UubWF0Y2goL3RpbWVkIG91dC8pKSB7XG4gICAgICAvLyBzb21ldGltZXMsIGVzcGVjaWFsbHkgaW4geGNvZGUgOCwgdGhlIHNpbSBoYW5nc1xuICAgICAgbG9nLmRlYnVnKCdLaWxsaW5nIHNpbXVsYXRvciB0aW1lZCBvdXQuIFVzaW5nIGtpbGxhbGwgc2lnbmFsJyk7XG4gICAgICBhd2FpdCBleGVjKCdraWxsYWxsJywgW2FwcE5hbWVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nLmVycm9yQW5kVGhyb3coZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gd2FpdCBmb3IgYWxsIHRoZSBkZXZpY2VzIHRvIGJlIHNodXRkb3duIGJlZm9yZSBDb250aW51aW5nXG4gIC8vIGJ1dCBvbmx5IHByaW50IG91dCB0aGUgZmFpbGVkIG9uZXMgd2hlbiB0aGV5IGFyZSBhY3R1YWxseSBmdWxseSBmYWlsZWRcbiAgbGV0IHJlbWFpbmluZ0RldmljZXM7XG4gIGFzeW5jIGZ1bmN0aW9uIGFsbFNpbXNBcmVEb3duICgpIHtcbiAgICByZW1haW5pbmdEZXZpY2VzID0gW107XG4gICAgbGV0IGRldmljZXMgPSBhd2FpdCBnZXREZXZpY2VzKCk7XG4gICAgZGV2aWNlcyA9IF8uZmxhdHRlbihfLnZhbHVlcyhkZXZpY2VzKSk7XG4gICAgcmV0dXJuIF8uZXZlcnkoZGV2aWNlcywgKHNpbSkgPT4ge1xuICAgICAgbGV0IHN0YXRlID0gc2ltLnN0YXRlLnRvTG93ZXJDYXNlKCk7XG4gICAgICBsZXQgZG9uZSA9IHN0YXRlID09PSAnc2h1dGRvd24nIHx8XG4gICAgICAgICAgICAgICAgIHN0YXRlID09PSAndW5hdmFpbGFibGUnIHx8XG4gICAgICAgICAgICAgICAgIHN0YXRlID09PSAnZGlzY29ubmVjdGVkJztcbiAgICAgIGlmICghZG9uZSkge1xuICAgICAgICByZW1haW5pbmdEZXZpY2VzLnB1c2goYFNpbXVsYXRvciBub3Qgc2h1dCBkb3duOiAke3NpbS5uYW1lfSAoJHtzaW0uc2RrfSwgdWRpZDogYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHtzaW0udWRpZH0pIGlzIHN0aWxsIGluIHN0YXRlICcke3N0YXRlfSdgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkb25lO1xuICAgIH0pO1xuICB9XG4gIHRyeSB7XG4gICAgYXdhaXQgd2FpdEZvckNvbmRpdGlvbihhbGxTaW1zQXJlRG93biwge1xuICAgICAgd2FpdE1zOiA2MCAqIDEwMDAsXG4gICAgICBpbnRlcnZhbE1zOiAyMDBcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHJlbWFpbmluZ0RldmljZXMgJiYgcmVtYWluaW5nRGV2aWNlcy5sZW5ndGggIT09IDApIHtcbiAgICAgIGxvZy5lcnJvcignVGhlIGZvbGxvd2luZyBkZXZpY2VzIGFyZSBub3QgaW4gdGhlIGNvcnJlY3Qgc3RhdGU6Jyk7XG4gICAgICBmb3IgKGxldCBkZXZpY2Ugb2YgcmVtYWluaW5nRGV2aWNlcykge1xuICAgICAgICBsb2cuZXJyb3IoYCAgICAke2RldmljZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGVuZEFsbFNpbXVsYXRvckRhZW1vbnMgKCkge1xuICBsb2cuZGVidWcoJ0VuZGluZyBhbGwgc2ltdWxhdG9yIGRhZW1vbnMnKTtcbiAgZm9yIChsZXQgc2VydmljZVBhdHRlcm4gb2YgWydjb20uYXBwbGUuaXBob25lc2ltdWxhdG9yJywgJ2NvbS5hcHBsZS5Db3JlU2ltdWxhdG9yJ10pIHtcbiAgICBsb2cuZGVidWcoYEtpbGxpbmcgYW55IG90aGVyICR7c2VydmljZVBhdHRlcm59IGRhZW1vbnNgKTtcbiAgICBsZXQgbGF1bmNoQ3RsQ29tbWFuZCA9IGBsYXVuY2hjdGwgbGlzdCB8IGdyZXAgJHtzZXJ2aWNlUGF0dGVybn0gfCBjdXQgLWYgMyB8IHhhcmdzIC1uIDEgbGF1bmNoY3RsYDtcbiAgICB0cnkge1xuICAgICAgbGV0IHN0b3BDbWQgPSBgJHtsYXVuY2hDdGxDb21tYW5kfSBzdG9wYDtcbiAgICAgIGF3YWl0IGV4ZWMoJ2Jhc2gnLCBbJy1jJywgc3RvcENtZF0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLndhcm4oYENvdWxkIG5vdCBzdG9wICR7c2VydmljZVBhdHRlcm59IGRhZW1vbnMsIGNhcnJ5aW5nIG9uIGFueXdheSFgKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGxldCByZW1vdmVDbWQgPSBgJHtsYXVuY2hDdGxDb21tYW5kfSByZW1vdmVgO1xuICAgICAgYXdhaXQgZXhlYygnYmFzaCcsIFsnLWMnLCByZW1vdmVDbWRdKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy53YXJuKGBDb3VsZCBub3QgcmVtb3ZlICR7c2VydmljZVBhdHRlcm59IGRhZW1vbnMsIGNhcnJ5aW5nIG9uIGFueXdheSFgKTtcbiAgICB9XG4gIH1cbiAgLy8gd2FpdGluZyB1bnRpbCB0aGUgc2ltdWxhdG9yIHNlcnZpY2UgaGFzIGRpZWQuXG4gIHRyeSB7XG4gICAgYXdhaXQgd2FpdEZvckNvbmRpdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKCdiYXNoJywgWyctYycsXG4gICAgICAgIGBwcyAtZSAgfCBncmVwIGxhdW5jaGRfc2ltIHwgZ3JlcCAtdiBiYXNoIHwgZ3JlcCAtdiBncmVwIHwgYXdrIHsncHJpbnQkMSd9YF0pO1xuICAgICAgcmV0dXJuIHN0ZG91dC50cmltKCkubGVuZ3RoID09PSAwO1xuICAgIH0sIHt3YWl0TXM6IDUwMDAsIGludGVydmFsTXM6IDUwMH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2cud2FybihgQ291bGQgbm90IGVuZCBhbGwgc2ltdWxhdG9yIGRhZW1vbnMsIGNhcnJ5aW5nIG9uIWApO1xuICB9XG4gIGxvZy5kZWJ1ZygnRmluaXNoaW5nIGVuZGluZyBhbGwgc2ltdWxhdG9yIGRhZW1vbnMnKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gc2ltRXhpc3RzICh1ZGlkKSB7XG4gIC8vIHNlZSB0aGUgUkVBRE1FIGZvciBnaXRodWIuY29tL2FwcGl1bS9ub2RlLXNpbWN0bCBmb3IgZXhhbXBsZSBvdXRwdXQgb2YgZ2V0RGV2aWNlcygpXG4gIGxldCBkZXZpY2VzID0gYXdhaXQgZ2V0RGV2aWNlcygpO1xuXG4gIGRldmljZXMgPSBfLnRvUGFpcnMoZGV2aWNlcykubWFwKChwYWlyKSA9PiB7XG4gICAgcmV0dXJuIHBhaXJbMV07XG4gIH0pLnJlZHVjZSgoYSwgYikgPT4ge1xuICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgfSwgW10pO1xuICByZXR1cm4gISFfLmZpbmQoZGV2aWNlcywgKHNpbSkgPT4ge1xuICAgIHJldHVybiBzaW0udWRpZCA9PT0gdWRpZDtcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNhZmVSaW1SYWYgKGRlbFBhdGgsIHRyeU51bSA9IDApIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBmcy5yaW1yYWYoZGVsUGF0aCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICh0cnlOdW0gPCAyMCkge1xuICAgICAgaWYgKGVyci5tZXNzYWdlLmluZGV4T2YoJ0VOT1RFTVBUWScpICE9PSAtMSkge1xuICAgICAgICBsb2cuZGVidWcoYFBhdGggJyR7ZGVsUGF0aH0nIHdhcyBub3QgZW1wdHkgZHVyaW5nIGRlbGV0ZTsgcmV0cnlpbmdgKTtcbiAgICAgICAgcmV0dXJuIHNhZmVSaW1SYWYoZGVsUGF0aCwgdHJ5TnVtICsgMSk7XG4gICAgICB9IGVsc2UgaWYgKGVyci5tZXNzYWdlLmluZGV4T2YoJ0VOT0VOVCcpICE9PSAtMSkge1xuICAgICAgICBsb2cuZGVidWcoYFBhdGggJyR7ZGVsUGF0aH0nJyBkaWQgbm90IGV4aXN0IHdoZW4gd2UgdHJpZWQgdG8gZGVsZXRlLCBpZ25vcmluZ2ApO1xuICAgICAgICByZXR1cm4gc2FmZVJpbVJhZihkZWxQYXRoLCB0cnlOdW0gKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gaW5zdGFsbFNTTENlcnQgKHBlbVRleHQsIHVkaWQpIHtcbiAgbGV0IHRlbXBGaWxlTmFtZSA9IHBhdGgucmVzb2x2ZShgJHtfX2Rpcm5hbWV9L3RlbXAtc3NsLWNlcnQucGVtYCk7XG4gIGxldCBwYXRoVG9LZXljaGFpbiA9IHBhdGgucmVzb2x2ZShuZXcgU2ltdWxhdG9yKHVkaWQpLmdldERpcigpKTtcbiAgYXdhaXQgZnMud3JpdGVGaWxlKHRlbXBGaWxlTmFtZSwgcGVtVGV4dCk7XG4gIGxldCBjZXJ0aWZpY2F0ZSA9IG5ldyBDZXJ0aWZpY2F0ZSh0ZW1wRmlsZU5hbWUpO1xuICBhd2FpdCBjZXJ0aWZpY2F0ZS5hZGQocGF0aFRvS2V5Y2hhaW4pO1xuICByZXR1cm4gYXdhaXQgZnMudW5saW5rKHRlbXBGaWxlTmFtZSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHVuaW5zdGFsbFNTTENlcnQgKHBlbVRleHQsIHVkaWQpIHtcbiAgbGV0IHRlbXBGaWxlTmFtZSA9IHBhdGgucmVzb2x2ZShgJHtfX2Rpcm5hbWV9L3RlbXAtc3NsLWNlcnQucGVtYCk7XG4gIGxldCBwYXRoVG9LZXljaGFpbiA9IHBhdGgucmVzb2x2ZShuZXcgU2ltdWxhdG9yKHVkaWQpLmdldERpcigpKTtcbiAgYXdhaXQgZnMud3JpdGVGaWxlKHRlbXBGaWxlTmFtZSwgcGVtVGV4dCk7XG4gIGxldCBjZXJ0aWZpY2F0ZSA9IG5ldyBDZXJ0aWZpY2F0ZSh0ZW1wRmlsZU5hbWUpO1xuICBhd2FpdCBjZXJ0aWZpY2F0ZS5yZW1vdmUocGF0aFRvS2V5Y2hhaW4pO1xuICByZXR1cm4gYXdhaXQgZnMudW5saW5rKHRlbXBGaWxlTmFtZSk7XG59XG5cbmV4cG9ydCB7IGtpbGxBbGxTaW11bGF0b3JzLCBlbmRBbGxTaW11bGF0b3JEYWVtb25zLCBzYWZlUmltUmFmLCBzaW1FeGlzdHMsIGluc3RhbGxTU0xDZXJ0LCB1bmluc3RhbGxTU0xDZXJ0IH07XG4iXSwic291cmNlUm9vdCI6Ii4uLy4uIn0=
